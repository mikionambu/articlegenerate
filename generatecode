# -*- coding: utf-8 -*-
"""googlesheet記事生成テンプレートver.5.72.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JOiuZxUjmWStxgmMDzrb7-VYun3cKpes

他の競技や選手へのヒントを重視するようにプロンプト、あと、そこで指導者向けとか選手向けと書かれているのであればそれを優先
記録が複数ピックアップされている
記事履歴DBには載ったけど、記録シートには載っていない。あとWPで見出しとかが少し変

# 74d5764a
"""

!pip install --upgrade gspread google-auth

from google.colab import auth
import gspread
from google.auth import default

# Authenticate with Google
auth.authenticate_user()

# Authorize gspread
# Use the default credentials
creds, project = default()
client = gspread.authorize(creds)

print("認証が完了しました。")

# 必要パッケージ・認証など（既に実行済みの場合はスキップ可）

# Simplify pip install commands to ensure unidecode is installed
!pip install openai python-dotenv ipywidgets markdown unidecode --quiet

from google.colab import auth
auth.authenticate_user()

from google.colab import drive
drive.mount('/content/drive')


import gspread
from google.auth import default
creds, _ = default()
gc = gspread.authorize(creds)

from openai import OpenAI
import os
from dotenv import load_dotenv
load_dotenv("/content/drive/MyDrive/APIKEY.env")
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
article_assistant_id = os.getenv("ARTICLE_ASSISTANT_ID")

"""# y3_AF0Bjwf0A"""

# スプレッドシート読み込みと整形

import pandas as pd

SPREADSHEET_NAME = "指導DB"
ws_kadai = gc.open(SPREADSHEET_NAME).worksheet("課題")
ws_kiroku = gc.open(SPREADSHEET_NAME).worksheet("記録")
ws_kiji = gc.open(SPREADSHEET_NAME).worksheet("記事履歴DB")

df_kadai = pd.DataFrame(ws_kadai.get_all_records())
df_kiroku = pd.DataFrame(ws_kiroku.get_all_records())

# Attempt to read df_kiji
kiji_records = ws_kiji.get_all_records()
df_kiji = pd.DataFrame(kiji_records)

# Check if df_kiji is empty and has no columns, if so, initialize with expected columns
# This happens if the sheet is completely empty or only has a header row and no data.
if df_kiji.empty and len(df_kiji.columns) == 0:
    print("DEBUG: df_kiji is empty and has no columns. Attempting to get header row.")
    try:
        # Try to get the header row to define columns
        header_row = ws_kiji.row_values(1)
        if header_row:
            print(f"DEBUG: Header row found: {header_row}")
            # Create a new empty DataFrame with columns from the header row
            df_kiji = pd.DataFrame(columns=header_row)
            print("DEBUG: Initialized df_kiji with header columns.")
        else:
            # Fallback if even the header row is empty/missing
            print("DEBUG: Header row is also empty or could not be read. Initializing df_kiji with a default set of columns including '公開日'.")
            # Define a necessary set of columns based on how df_kiji is used later
            # Include '課題ID', '記事タイトル', '公開日', '公開URL', '読者タイプ' and any others used
            default_kiji_columns = ['課題ID', '記事タイトル', '記事本文', '公開日', '公開URL', '視点', 'フェーズ', 'テンプレ生成元あり？', '関連課題', 'テンプレート', '最終記録日（記事化ベース）', 'ロールアップ', '記事化ステータス', '読者タイプ', '作成日']
            df_kiji = pd.DataFrame(columns=default_kiji_columns)
            print(f"DEBUG: Initialized df_kiji with default columns: {default_kiji_columns}")

    except Exception as e:
        print(f"Error during df_kiji initialization based on header: {e}")
        # If header reading fails, initialize with default columns as a last resort
        default_kiji_columns = ['課題ID', '記事タイトル', '記事本文', '公開日', '公開URL', '視点', 'フェーズ', 'テンプレ生成元あり？', '関連課題', 'テンプレート', '最終記録日（記事化ベース）', 'ロールアップ', '記事化ステータス', '読者タイプ', '作成日']
        df_kiji = pd.DataFrame(columns=default_kiji_columns)
        print(f"DEBUG: Initialized df_kiji with default columns due to error: {default_kiji_columns}")


# '日付' 列を明示的なフォーマットで datetime に変換し、エラーを強制的に NaT にする
df_kiroku['日付'] = pd.to_datetime(df_kiroku['日付'], format='%Y-%m-%d', errors='coerce')

# Now, convert '公開日' to datetime. This should not raise KeyError if df_kiji has columns.
# Check if '公開日' column exists before attempting conversion, just in case the default columns were used and it wasn't included (though it should be).
if '公開日' in df_kiji.columns:
    print("DEBUG: '公開日' column found in df_kiji. Attempting to convert to datetime.")
    df_kiji['公開日'] = pd.to_datetime(df_kiji['公開日'], format='%Y-%m-%d', errors='coerce')
    print("DEBUG: '公開日' column conversion attempted.")
else:
    print("WARNING: '公開日' column not found in df_kiji after initialization. Cannot convert to datetime.")
    # If '公開日' is missing, subsequent steps might fail. Ensure it exists.
    # This should not happen if the default_kiji_columns include '公開日'.
    if '公開日' not in df_kiji.columns:
         df_kiji['公開日'] = pd.NaT # Add the column with NaT if it's still missing


# DEBUG: Print final df_kiji columns after potential initialization
print("DEBUG: Final columns in df_kiji:")
print(df_kiji.columns)

"""# 0hrYIAcNwmQ5"""

# 対象課題IDの抽出ロジック

# 各課題の最新記録日と公開日を取得
latest_kiroku = df_kiroku.groupby('課題ID')['日付'].max().reset_index().rename(columns={'日付': '最新記録日'})
latest_kiji = df_kiji.groupby('課題ID')['公開日'].max().reset_index().rename(columns={'公開日': '最新公開日'})

# 結合して比較
df_check = pd.merge(df_kadai, latest_kiroku, on='課題ID', how='left')
df_check = pd.merge(df_check, latest_kiji, on='課題ID', how='left')

# 判定列（記事化すべき）追加
df_check['記事化対象'] = df_check.apply(
    lambda row: pd.isna(row['最新公開日']) or (pd.notna(row['最新記録日']) and row['最新記録日'] > row['最新公開日']),
    axis=1
)

# 記事化対象のみ抽出
df_targets = df_check[df_check['記事化対象']]

"""# knxud1ZDpKeY"""

def format_full_record(record: dict) -> str:
    fields = [
        "課題ID", "日付", "次回方針", "テーマ", "状態", "原因",
        "働きかけのテーマ", "やりとり", "選手の反応や悩み",
        "過去のバイアスや変化を邪魔している生き方や出来事",
        "使用した比喩や伝え方", "変化", "鍵となった問いかけやバイアス・ブロックの解除",
        "指導時のチェックポイント", "記事化ステータス", "他の選手や競技へのヒント"
    ]
    lines = []
    for key in fields:
        val = record.get(key, "")
        if isinstance(val, list):  # マルチ選択やリッチテキスト対策
            val = ", ".join(val)
        lines.append(f"■{key}: {val}")
    return "\n".join(lines)

"""# k0KiOi68ElQ2"""

# 記録が存在する課題IDだけを抽出
valid_kiroku_kadai_ids = df_kiroku["課題ID"].dropna().unique().tolist()

# 有効な課題IDのみから master データを抽出
df_kadai_valid = df_kadai[df_kadai["課題ID"].isin(valid_kiroku_kadai_ids)]

# ▼必要に応じて一覧を表示（オプション）
display(df_kadai_valid[["課題ID", "選手ID", "課題タイトル"]])

# たとえば最初のものを sample_row に設定（もしくは UI選択）
sample_row = df_kadai_valid.iloc[0]

"""# f55vRBziecB6"""

import pandas as pd

def format_kiroku_block(df_kiroku, kadai_id):
    """該当課題IDのすべての記録を整形して1つの文字列にまとめる"""
    block = ""
    target_rows = df_kiroku[df_kiroku["課題ID"] == kadai_id]
    for i, row in target_rows.iterrows():
        block += f"\n--- 指導記録 {i+1} ---\n"
        for col in df_kiroku.columns:
            value = row[col]
            value = str(value) if not pd.isna(value) else ""
            block += f"{col}: {value}\n"
    return block.strip()

"""# 0901cac8"""

def parse_player_id_with_grade(player_id: str) -> str:
    """
    選手IDを匿名化された表現に変換するプレースホルダー関数。
    例: MU_2008M_TOSH -> (学年) 男子選手 A
    """
    parts = player_id.split('_')
    if len(parts) >= 3:
        gender = "男子" if parts[2].startswith('M') else "女子"
        # 学年情報を抽出（例: 2008M -> 2008）
        try:
            year = int(parts[1][:4]) # Assuming year is the first 4 digits after MU/MA/KO
            # ここで必要に応じて学年を計算（例: 2024年を基準に計算するなど）
            # 簡単のため、ここでは単に「(年度)の」と表示
            anonymized_grade = f"{year}年度の" # Placeholder for grade calculation
        except ValueError:
            anonymized_grade = "" # If year cannot be parsed


        # ユニークな選手を示すための識別子（例: A, B, Cなど、ここではシンプルに順次付与されると仮定）
        # 実際には課題IDや選手IDから一意に決まる識別子を生成するロジックが必要になる場合があります
        # ここでは簡単なPlaceholderとして「選手」とします。
        anonymized_identifier = "選手" # Placeholder for a unique identifier per player

        return f"{anonymized_grade}{gender}{anonymized_identifier}"
    else:
        return f"選手 ({player_id})" # Simple fallback for unexpected formats

# Check if the functions are defined
try:
    # Check publish_to_note
    if 'publish_to_note' not in globals() or not callable(publish_to_note):
        print("Function 'publish_to_note' is not defined or not callable. Re-running cell 92bf0505.")
        # Assuming cell 92bf0505 defines publish_to_note
        # You would typically re-execute the cell programmatically or manually in a notebook
        # In this simulated environment, we just print the instruction to re-run.
        # For a real execution, you might use get_ipython().run_cell_id('92bf0505') if available
        pass # Placeholder for re-execution logic

    # Check publish_to_wordpress
    if 'publish_to_wordpress' not in globals() or not callable(publish_to_wordpress):
        print("Function 'publish_to_wordpress' is not defined or not callable. Re-running cell 3414833b.")
        # Assuming cell 3414833b defines publish_to_wordpress
        pass # Placeholder for re-execution logic

    # Check post_to_x
    if 'post_to_x' not in globals() or not callable(post_to_x):
        print("Function 'post_to_x' is not defined or not callable. Re-running cell 6ca6f773.")
        # Assuming cell 6ca6f773 defines post_to_x
        pass # Placeholder for re-execution logic

    print("All required publishing functions appear to be defined.")

except Exception as e:
    print(f"An error occurred while checking function definitions: {e}")

# Note: In a real notebook, you would use get_ipython().run_cell_id('cell_id')
# or similar methods to re-run cells if they were not executed successfully.
# Since the previous execution history shows these cells ran successfully,
# they should be available in the kernel's global scope.

"""# dbdd9dfe"""

import gspread
import pandas as pd
from google.auth import default
import datetime
# Ensure gspread.utils is accessible
import gspread.utils


def update_article_history(publishing_results: dict, df_kiji: pd.DataFrame, spreadsheet_name: str = "指導DB", worksheet_name: str = "記事履歴DB") -> pd.DataFrame:
    """
    Updates the df_kiji DataFrame and the Google Sheet with article publishing results.

    Args:
        publishing_results (dict): The results dictionary from automated_article_publishing_workflow.
        df_kiji (pd.DataFrame): The DataFrame for the article history DB (記事履歴DB).
        spreadsheet_name (str): The name of the Google Spreadsheet.
        worksheet_name (str): The name of the worksheet for article history.

    Returns:
        pd.DataFrame: The updated df_kiji DataFrame.
    """
    kadai_id = publishing_results.get('kadai_id')
    if not kadai_id:
        print("Error: publishing_results dictionary does not contain 'kadai_id'. Cannot update history.")
        return df_kiji # Return original DataFrame if Kadai ID is missing

    print(f"--- Updating article history for Kadai ID: {kadai_id} ---")

    # Find the row in df_kiji for the current Kadai ID, or prepare a new row
    # Assuming '課題ID' is the unique identifier in df_kiji
    target_row_index = df_kiji[df_kiji['課題ID'] == kadai_id].index

    if target_row_index.empty:
        print(f"Warning: Kadai ID {kadai_id} not found in df_kiji. Appending a new row.")
        # Prepare a new row dictionary with initial data
        new_row_data = {'課題ID': kadai_id}
        # Add other essential columns if they are not automatically handled by gspread append
        # Based on df_kiji structure: '記事タイトル', '記事本文', '公開日', '公開URL', '視点', 'フェーズ', 'テンプレ生成元あり？', '関連課題', 'テンプレート', '最終記録日（記事化ベース）', 'ロールアップ', '記事化ステータス', '読者タイプ', '作成日'
        # Initialize potentially missing columns with default values
        for col in ['記事タイトル', '記事本文', '公開日', '公開URL', '視点', 'フェーズ', 'テンプレ生成元あり？', '関連課題', 'テンプレート', '最終記録日（記事化ベース）', 'ロールアップ', '記事化ステータス', '読者タイプ', '作成日']:
             if col not in new_row_data:
                 new_row_data[col] = '' # Use empty string or appropriate default

        # Append the new row to the DataFrame
        # Ensure column order matches the original df_kiji or is handled by gspread
        # Use pd.concat to append a new row and ensure the DataFrame structure is maintained
        # Create a DataFrame from the new row data, ensuring columns are in the same order as df_kiji
        new_row_df = pd.DataFrame([new_row_data], columns=df_kiji.columns)
        df_kiji_updated = pd.concat([df_kiji, new_row_df], ignore_index=True)

        target_row_index = df_kiji_updated[df_kiji_updated['課題ID'] == kadai_id].index
        print(f"Added new row for Kadai ID {kadai_id} at index {target_row_index[0]}.")
    else:
         print(f"Found existing row for Kadai ID {kadai_id} at index {target_row_index[0]}. Updating.")
         df_kiji_updated = df_kiji.copy() # Work on a copy to avoid modifying the original df directly before gspread update


    # Get the row index for Google Sheet update (gspread is 0-indexed, pandas is 0-indexed)
    # We need the actual row number in the sheet, which is pandas index + 2 (1 for 0-index, 1 for header row)
    sheet_row_index = target_row_index[0] + 2


    # Update DataFrame row with publishing results
    current_time = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    # Update '記事化ステータス' based on overall status
    overall_status = publishing_results.get('overall_status', 'unknown')
    if overall_status == 'success':
        df_kiji_updated.loc[target_row_index, '記事化ステータス'] = '公開完了'
    elif overall_status == 'partial_success':
         df_kiji_updated.loc[target_row_index, '記事化ステータス'] = '一部公開成功'
    else:
         df_kiji_updated.loc[target_row_index, '記事化ステータス'] = '公開失敗'


    # Update URL and Public Date/Time based on successful platforms
    # Prioritize WordPress URL if available and successful for '公開URL' and '公開日'
    wordpress_publish_result = publishing_results.get("wordpress_publish", {})
    if wordpress_publish_result.get("status") == "success":
        wp_url = wordpress_publish_result.get("url")
        if wp_url:
            df_kiji_updated.loc[target_row_index, '公開URL'] = wp_url
            # Set '公開日' to current time if it's empty or if WordPress was the primary success
            if pd.isna(df_kiji_updated.loc[target_row_index, '公開日']) or df_kiji_updated.loc[target_row_index, '公開日'] == '':
                 df_kiji_updated.loc[target_row_index, '公開日'] = current_time


    # You could add logic here for other platforms if their APIs were functional
    # e.g., if note_publish_result.get("status") == "success": ...


    # You could also update other fields if they were part of the publishing_results
    # e.g., df_kiji_updated.loc[target_row_index, '記事タイトル'] = publishing_results.get('title', df_kiji_updated.loc[target_row_index, '記事タイトル'])


    # --- Update Google Sheet ---
    try:
        creds, _ = default()
        gc = gspread.authorize(creds)
        sh = gc.open(spreadsheet_name)
        ws = sh.worksheet(worksheet_name)

        # Get all header values from the sheet to map DataFrame columns to sheet columns
        header_values = ws.row_values(1)
        header_map = {col_name: header_values.index(col_name) for col_name in header_values}

        # Prepare values to update for the specific row
        # Iterate through columns that were updated in the DataFrame
        # Ensure values match the sheet's column order using header_map
        values_to_update = [''] * len(header_values) # Initialize with empty strings or existing sheet values if needed

        # Get the row data from the *updated* DataFrame copy
        updated_row_data = df_kiji_updated.loc[target_row_index].iloc[0]

        for col_name, value in updated_row_data.items():
             if col_name in header_map:
                 # Convert datetime objects or NaT to string representation if necessary
                 if pd.isna(value):
                     values_to_update[header_map[col_name]] = ''
                 elif isinstance(value, datetime.datetime):
                      values_to_update[header_map[col_name]] = value.strftime('%Y-%m-%d %H:%M:%S') # Or appropriate format
                 else:
                     values_to_update[header_map[col_name]] = str(value)


        # Update the specific row in the Google Sheet
        # Construct the range string, e.g., 'A5:Z5' for row 5
        # Use gspread.utils.colrow_to_a1 correctly
        end_column_letter = gspread.utils.colrow_to_a1(1, len(header_values))[0] # Get the letter for the last column (col_index is 1-based)
        update_range = f'A{sheet_row_index}:{end_column_letter}{sheet_row_index}'

        print(f"Updating Google Sheet range: {update_range} with data: {values_to_update}")
        ws.update(update_range, [values_to_update])
        print(f"Google Sheet updated successfully for Kadai ID: {kadai_id}.")


    except Exception as e:
        print(f"Error updating Google Sheet for Kadai ID {kadai_id}: {e}")
        # Even if sheet update fails, return the updated DataFrame
        return df_kiji_updated

    # Return the updated DataFrame
    return df_kiji_updated


# --- Example Usage (assuming automated_article_publishing_workflow was run) ---
# Use the 'publishing_results' variable from the previous cell's example execution.
# Check if 'publishing_results' exists and has data before attempting to update.

# if 'publishing_results' in locals() and publishing_results:
#      print("\n--- Running update_article_history with publishing results ---")
#      # Call the function and re-assign the global df_kiji with the returned DataFrame
#      df_kiji = update_article_history(publishing_results, df_kiji)
#      print("\nGlobal df_kiji variable has been updated.")
#      # Display the updated row(s) in the DataFrame (optional)
#      # display(df_kiji[df_kiji['課題ID'] == publishing_results['kadai_id']])
# else:
#      print("\nSkipping update_article_history: No publishing results available from the previous step.")

print("\nThe `update_article_history` function is defined and corrected to return the updated DataFrame.")
print("This function updates the df_kiji DataFrame and the Google Sheet based on publishing results.")

# Re-run the update with the simplified results from the previous step
# Ensure simplified_publishing_results and df_kiji are available
if 'simplified_publishing_results' in locals() and 'df_kiji' in globals():
    print("\n--- Re-running update_article_history with simplified results ---")
    try:
        df_kiji = update_article_history(simplified_publishing_results, df_kiji)
        print("\nGlobal df_kiji variable has been updated after re-running update.")
        # Optional: Display the updated row(s)
        updated_kadai_id = simplified_publishing_results.get('kadai_id')
        if updated_kadai_id and updated_kadai_id != 'Unknown ID for Update':
             print(f"\n--- Updated row for Kadai ID: {updated_kadai_id} in df_kiji (after re-run) ---")
             display(df_kiji[df_kiji['課題ID'] == updated_kadai_id])

    except Exception as e:
         print(f"Error calling update_article_history after re-run: {e}")
else:
     print("\nSkipping re-run of update_article_history: Required variables not available.")

"""# 50cec76d"""

# 記事本文を生成する関数（Placeholder -> Implementation）
import os
import time
from openai import OpenAI
import textwrap # textwrapをインポート
import re # reをインポートして読者タイプを抽出
import traceback # Import traceback for error printing

def article_writer(template_text, record_text, kadai_id, article_title, article_style, reader_type): # Corrected function signature to accept style and reader_type
    """
    最終的な記事本文を生成する関数。
    Args:
        template_text (str): テンプレート生成アシスタントからの出力。
        record_text (str): 対象課題の整形済み指導記録全文。
        kadai_id (str): 対象課題の課題ID。
        article_title (str): ユーザーが選択/入力した記事タイトル。
        article_style (str): 生成する記事のスタイル ('narrative', 'record').
        reader_type (str): テンプレートから抽出された読者タイプ（例: '指導者', '保護者', '選手'）.

    Returns:
        str: 生成された記事本文、またはNone if generation failed.
    """
    print(f"---- 記事本文生成を開始します (スタイル: {article_style}, 読者タイプ: {reader_type}) ----")
    print(f"対象課題ID: {kadai_id}")
    print(f"使用する記事タイトル: {article_title}")

    article_body = None # Initialize article_body to None

    try:
        client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
        # ユーザーが指定したWRITER_ASSISTANT_IDを使用
        article_body_assistant_id = os.getenv("WRITER_ASSISTANT_ID") # WRITER_ASSISTANT_IDを使用

        if not article_body_assistant_id:
             print("エラー: 環境変数 'WRITER_ASSISTANT_ID' が設定されていません。記事本文生成AssistantのIDが必要です。")
             return None # Return None on error


        # 記事本文生成のためのプロンプトを作成（スタイルによって内容を変更）
        base_instructions = textwrap.dedent(f"""
以下のテンプレート、指導記録全文、および「使用する記事タイトル」を元に、記事の本文を生成してください。
テンプレートの構成案や意図、指導記録の具体的な内容を最大限に尊重してください。
生成するのは記事の本文のみで、タイトルや構成案などのテンプレート情報は含めないでください。

**「使用する記事タイトル」は、ユーザーが最終的に選んだタイトルであり、生成する記事本文の主題となります。このタイトルに沿って記事本文を構成し、タイトルが示す内容を具体的に掘り下げてください。記事本文の冒頭や重要な箇所で、このタイトルが示すテーマが明確に伝わるように記述してください。**

**重要: 指導記録に含まれる可能性のある個人名（選手名など）は絶対に使用しないでください。** 選手について言及する場合は、「選手」「彼」「彼女」「〇〇さん（仮名）」など、個人を特定できない一般的な呼称や仮名を使用してください。

記録はテニスの指導に関するものですが、記事化にあたって
「保護者」「選手」対象の場合は、あまり専門的な言葉や難しい言葉は使わず、日常的に使う言葉で作成下さい。
「保護者」「指導者」対象の場合、テニスという競技に限定せず、他のスポーツや一般的な子育て・教育の文脈にも応用できるような、より汎用的な視点や表現を含めてください。特定のテニス用語は避け、一般的な言葉に置き換えるなど工夫してください。

--- テンプレート ---
{template_text}

--- 指導記録全文 ---
{record_text}

--- 使用する記事タイトル ---
{article_title if article_title else "（タイトル指定なし）"}

""").strip()

        style_instructions = ""
        if article_style == 'narrative':
            # Refined narrative style instructions based on reader_type (Mapping to Note with audience-specific tone)
            style_instructions = textwrap.dedent(f"""
            **記事本文は、読者タイプが「{reader_type}」であることを考慮し、ご提示いただいたプロンプトのトーンと構成案に沿ったコーチング記事としてください。**

            【読者タイプ】: {reader_type}向け

            【記事の目的】
            読者が共感しやすい文脈で、具体的な悩み・指導・変化のプロセスを伝え、その読者にとっての学びやヒントになるような内容にしてください。

            【トーンの指示】
            """).strip()

            if reader_type == '指導者':
                style_instructions += textwrap.dedent("""
                - 指導者向け：論理的・構造的。背景→観察→働きかけ→変化→教訓の順に。**個人的な「すごさ」を強調せず、客観的な視点と実践知の共有に焦点を当ててください。**
                - テニスという競技に限定せず、他のスポーツや一般的な子育て・教育の文脈にも応用できるような、より汎用的な視点や表現を含めてください。特定のテニス用語は避け、一般的な言葉に置き換えるなど工夫してください。
                【構成の提案】
                1. 課題の導入（悩みやできなさの描写）
                2. その背景や原因の探求
                3. 働きかけや工夫したこと
                4. 起こった変化や気づき
                5. 読者への問いやメッセージ
                【語尾・文体】
                - です・ます調／専門性を意識した言葉選び
                【注意点】
                - 汎用的視点（他競技や子育て等への応用）は、文章の中盤〜終盤、またはまとめ部分で触れるようにしてください。冒頭や主要な論点では、具体的な指導場面・課題・変化に基づいた描写を優先してください。
                - 選手の「変化」については、抽象的な心の変化だけでなく、**行動・選択・体の動かし方・言葉の使い方など、外から観察できる具体的な変化**を優先的に描写してください。
                - 執筆する際は、客観的な視点で記載し、知見は、たまたま自分が気づいた事実や真実を世の中に共有するようなスタンスで、自己主張を抑えてください。
                """).strip()
            elif reader_type == '保護者':
                style_instructions += textwrap.dedent("""
                - 保護者向け：親しみやすく、共感を重視したトーン。わが子のような描写から入ると効果的。
                - あまり専門的な言葉や難しい言葉は使わず、日常的に使う言葉で作成下さい。
                - テニスという競技に限定せず、他のスポーツや一般的な子育て・教育の文脈にも応用できるような、より汎用的な視点や表現を含めてください。特定のテニス用語は避け、一般的な言葉に置き換えるなど工夫してください。
                【構成の提案】
                1. 課題の導入（悩みやできなさの描写）
                2. その背景や原因の探求
                3. 働きかけや工夫したこと
                4. 起こった変化や気づき
                5. 読者への問いやメッセージ
                【語尾・文体】
                - やさしい語り口。時に「〜かもしれません」と余白を持たせる
                【注意点】
                - 汎用的視点（他競技や子育て等への応用）は、文章の中盤〜終盤、またはまとめ部分で触れるようにしてください。冒頭や主要な論点では、具体的な指導場面・課題・変化に基づいた描写を優先してください。
                - 選手の「変化」については、抽象的な心の変化だけでなく、**行動・選択・体の動かし方・言葉の使い方など、外から観察できる具体的な変化**を優先的に描写してください。
                - 執筆する際は、客観的な視点で記載し、知見は、たまたま自分が気づいた事実や真実を世の中に共有するようなスタンスで、自己主張を抑えてください。
                """).strip()
            elif reader_type == '選手':
                style_instructions += textwrap.dedent("""
                - 選手向け：やさしく語りかけるようなトーン。悩みの共感、挑戦と少しの変化、安心感を意識する。
                - あまり専門的な言葉や難しい言葉は使わず、日常的に使う言葉で作成下さい。
                【構成の提案】
                1. 課題の導入（悩みやできなさの描写）
                2. その背景や原因の探求
                3. 働きかけや工夫したこと
                4. 起こった変化や気づき
                5. 読者への問いやメッセージ
                【語尾・文体】
                - フランクすぎないが親しみやすく、前向きな語り口（例：「こんなふうに考えてみたらどうかな？」）
                【注意点】
                - 執筆する際は、読者として想定している選手が、希望を持てるような書き方を行い、またそのためのティップスを共有するようなスタンスで書いてください。
                """).strip()
            else:
                 # Default or general narrative instructions if reader type is unknown
                 style_instructions += textwrap.dedented("""
                 - 読者タイプ不明またはその他向け: 指導の過程で起こった選手の変化や、それを引き出した指導者の働きかけに焦点を当てた物語としてください。読後感が良く、何らかの学びや気づきが得られるような内容にしてください。**個人的な「すごさ」を強調せず、客観的な視点と実践知の共有に焦点を当ててください。**
                 【構成の提案】
                 1. 課題の導入
                 2. 背景・原因
                 3. 働きかけ
                 4. 変化・気づき
                 5. まとめ・教訓
                 【語尾・文体】
                 - です・ます調
                 """).strip()


        elif article_style == 'record':
            # Refined record style instructions focusing on factual, logical, and practical insights (Mapping to WordPress)
            # Corrected function name from dedented to dedent
            style_instructions = textwrap.dedent("""
            **記事本文は、指導記録の内容を元に、変化やきっかけの様子が読者（特に指導者や保護者）に分かりやすく伝わるような、記録風のスタイルで記述してください。以下の点に重点を置いてください：**

            - **事実に基づいた論理的な構成:** 指導前後の「状態」、行われた「働きかけ」や「やりとり」、それに対する「選手の反応や悩み」、そして「変化」に至る過程を、記録から抽出した事実を基に、論理的に分かりやすく説明してください。
            - **原因、働きかけ、変化の明確化:** 「何が原因で、どう働きかけたら、どう変化したか」という因果関係が明確に伝わるように記述してください。
            - **具体的なエピソード:** 記録にある具体的なエピソードややりとりを引用・参照し、説得力を持たせてください。
            - **実践的な学び:** 他の指導者や保護者が自身の状況に当てはめて考えられるように、この事例から得られる指導のポイント、選手の成長を促すためのヒント、課題解決のための具体的なアプローチなどを明確に提示してください。
            - **客観的で情報提供的なトーン:** 個人的な感情や**自分の「すごさ」を強調することなく**、情報を提供し、読者に学びを促すような客観的なトーンを心がけてください。
            - **簡潔なまとめ:** 不要な装飾を避け、要点を絞って簡潔にまとめてください。
            """).strip()
        else:
            print(f"警告: 不明な記事スタイル '{article_style}' が指定されました。デフォルトのスタイルで生成します。")
            # Fallback or a default style could be added here

        prompt = base_instructions + "\n\n" + style_instructions + "\n\n--- 記事本文 ---\n"

        # print(f"DEBUG: Final Prompt for article_writer:\n{prompt}") # Debug: Print the final prompt


        # Assistants APIで記事本文を生成
        thread = client.beta.threads.create()
        client.beta.threads.messages.create(thread_id=thread.id,
                                            role="user",
                                            content=prompt)
        run = client.beta.threads.runs.create(thread_id=thread.id,
                                              assistant_id=article_body_assistant_id)

        print("記事本文生成Assistantを実行中...")
        while True:
            stat = client.beta.threads.runs.retrieve(thread_id=thread.id,
                                                     run_id=run.id)
            if stat.status in ["completed", "failed", "cancelled", "expired"]: # Check for all final states
                print(f"記事本文生成Assistant実行完了。ステータス: {stat.status}")
                break
            if stat.status == "requires_action":
                 print("Function calling required, but not implemented in this flow.")
                 print(f"Required action: {stat.required_action.submit_tool_outputs.tool_calls}")
                 stat.status = "failed" # Force status to failed for this simple flow
                 break

            time.sleep(2) # 待ち時間を少し長くする

        # Corrected message retrieval
        if stat and stat.status == "completed":
             reply = client.beta.threads.messages.list(thread_id=thread.id)
             print(f"DEBUG: Assistant reply object type: {type(reply)}")
             print(f"DEBUG: Number of messages in reply: {len(reply.data) if reply.data else 0}")

             if reply.data and reply.data[0].content:
                 article_body = ""
                 for content_block in reply.data[0].content:
                     if content_block.type == 'text':
                         article_body += content_block.text.value + "\n"
                 article_body = article_body.strip()

                 print(f"DEBUG: Extracted article_body length: {len(article_body)}")
                 if article_body:
                      print("\n---- 生成された記事本文 ----\n") # Keep printing here for immediate feedback
                      print(article_body)
                      print("\n-------------------------\n")
                      return article_body # Return the generated article body
                 else:
                      print("警告: Assistantからの応答にテキストコンテンツは含まれていましたが、内容は空でした。")
                      return None


             else:
                 print("警告: 記事本文生成Assistantからの応答がありませんでした、またはテキストコンテンツがありませんでした。")
                 return None # Return None if no response or no text content
        elif stat:
             print(f"記事本文生成Assistantの実行が完了しませんでした。最終ステータス: {stat.status}")
             if stat.last_error:
                 print(f"エラー詳細: {stat.last_error}")
             return None
        else:
             print("警告: Assistant実行ステータスが取得できませんでした。")
             return None


    except Exception as e:
        print(f"記事本文生成処理中にエラーが発生しました: {e}")
        print(traceback.format_exc()) # Print traceback for exception
        return None # Return None on exception


# 記事本文生成のためのUIを表示する関数（変更あり）
import ipywidgets as widgets
from IPython.display import display, clear_output
import re # Already imported
import os # Already imported
import json # Added import for json
import traceback # Import traceback for error printing

# MODIFIED function signature to accept article_title
def article_writer_ui(template_text, record_text, kadai_id, article_title):
    """
    ユーザーに本文生成スタイルを選択させ、記事本文生成関数を呼び出すUI。
    Args:
        template_text (str): テンプレート生成アシスタントからの出力。
        record_text (str): 対象課題の整形済み指導記録全文。
        kadai_id (str): 対象課題の課題ID。
        article_title (str): ユーザーが選択/入力した記事タイトル（タイトル生成ステップから渡される）。
    """
    print("\n---- 記事本文生成UI ----")
    # Use the passed article_title here
    print(f"使用する記事タイトル: {article_title}")
    print("生成したい記事のスタイルを選択してください。")

    # テキストエリアは、本文生成のための「追加の詳細指示」として残す
    further_instructions_input = widgets.Textarea(
        value='',
        placeholder='記事本文生成のための追加の詳細指示を入力してください（例: 特定の点をさらに強調する、特定の表現を避けるなど）',
        description='追加指示:',
        disabled=False,
        layout=widgets.Layout(width='80%', height='100px')
    )

    # スタイル選択ボタンを配置
    note_narrative_button = widgets.Button(description='Note用記事生成（ナラティブ）', button_style='info')
    wp_record_button = widgets.Button(description='WordPress記事生成（記録風）', button_style='success')

    output_area = widgets.Output()

    # 読者タイプをテンプレートテキストから抽出
    reader_type_match = re.search(r"【読者タイプ】:\s*(.+?)向け", template_text)
    extracted_reader_type = reader_type_match.group(1).strip() if reader_type_match else "不明"
    print(f"抽出された読者タイプ: {extracted_reader_type}")


    # ボタンクリック時のハンドラ関数
    def on_generate_button_clicked(b):
        style = 'narrative' if b.description == 'Note用記事生成（ナラティブ）' else 'record'
        print(f"DEBUG: {b.description} clicked. Style: {style}") # DEBUG

        with output_area:
            clear_output(wait=True)
            if style == 'unknown':
                 print("エラー: 不明なボタンがクリックされました。")
                 return
            print(f"\n選択されたスタイル '{style}' で記事本文を生成中です...")

            # Call article_writer and capture the returned body
            # Passing all required arguments: template_text, record_text, kadai_id, article_title, style, extracted_reader_type
            # Use the article_title passed to article_writer_ui
            generated_article_body = article_writer(template_text, record_text, kadai_id, article_title, style, extracted_reader_type)

            if generated_article_body:
                print("\n記事本文生成処理が完了しました。結果を表示/投稿します。")

                # --- Display generated content in editable Textareas ---
                print("\n--- 生成された記事内容を確認・編集 ---")

                # Pre-populate title textarea with the article_title passed to article_writer_ui
                edited_title_input = widgets.Textarea(
                    value=article_title, # Use the passed article_title as initial value
                    description='記事タイトル:',
                    layout=widgets.Layout(width='95%', height='50px')
                )

                edited_body_input = widgets.Textarea(
                    value=generated_article_body, # Use the generated body as initial value
                    description='記事本文:',
                    layout=widgets.Layout(width='95%', height='300px')
                )

                # Display the editable fields
                display(edited_title_input)
                display(edited_body_input)

                # --- Add buttons for next actions ---
                print("\n--- 次のステップ ---")
                if style == 'narrative':
                    # For Note (narrative), suggest copy-paste
                    print("上記の内容をコピーしてNoteに貼り付けてください。")
                    # No automated publishing button for Note in this flow
                elif style == 'record':
                    # For WordPress (record), add a publish button
                    publish_wp_button = widgets.Button(description='WordPressに下書き投稿', button_style='success')

                    def on_publish_wp_button_clicked(b):
                         print("DEBUG: on_publish_wp_button_clicked triggered.") # DEBUG
                         with output_area:
                             clear_output(wait=True)
                             print("WordPressに投稿しています...")

                             # Get potentially edited title and body from the text areas
                             final_title_to_publish = edited_title_input.value.strip()
                             final_body_to_publish = edited_body_input.value.strip()

                             if not final_title_to_publish or not final_body_to_publish:
                                 print("エラー: タイトルまたは本文が空です。投稿をスキップします。")
                                 return

                             # Check for WordPress credentials and attempt publishing
                             wordpress_url = os.getenv("WORDPRESS_URL")
                             wordpress_user = os.getenv("WORDPRESS_USER")
                             wordpress_password = os.getenv("WORDPRESS_PASSWORD")

                             wp_publish_result = None # Initialize WP publish result

                             if all([wordpress_url, wordpress_user, wordpress_password]):
                                 print("\nWordPress認証情報が見つかりました。WordPressへの投稿を試みます...")
                                 try:
                                     # Assume publish_to_wordpress function is defined elsewhere and accessible
                                     # It takes title, content (HTML expected), and potentially tags/categories
                                     # The generated_article_body is currently text/markdown, may need conversion if WP API requires HTML
                                     # For simplicity, we pass the raw text and rely on WP/plugin to handle markdown if needed.
                                     # In a real scenario, you might use a library like markdown2 or pandoc to convert to HTML.
                                     wordpress_content_for_api = final_body_to_publish # Use the edited body

                                     # Check if publish_to_wordpress is defined
                                     if 'publish_to_wordpress' in globals() and callable(publish_to_wordpress):
                                         wp_publish_result = publish_to_wordpress(
                                             wordpress_url=wordpress_url,
                                             username=wordpress_user,
                                             password=wordpress_password,
                                             title=final_title_to_publish, # Use the edited title
                                             content=wordpress_content_for_api,
                                             tags=None, # Add tag logic if needed
                                             categories=None # Add category logic if needed
                                         )
                                         print("\n--- WordPress Publish Result ---")
                                         print(json.dumps(wp_publish_result, indent=2, ensure_ascii=False))

                                         # --- Automatically call update_article_history if WordPress publish was successful ---
                                         if wp_publish_result and wp_publish_result.get("status") == "success":
                                             print("\nWordPress投稿が成功しました。記事履歴の自動更新を試みます...")

                                             # Prepare the results dictionary for update_article_history
                                             # This mimics the structure expected by update_article_history in append mode
                                             # Need to ensure df_kiji is available in global scope
                                             if 'df_kiji' in globals():
                                                 simplified_publishing_results_for_append = {
                                                     "kadai_id": kadai_id, # Use the original kadai_id
                                                     "overall_status": wp_publish_result.get("status", "unknown"), # Use WP status for overall
                                                     "wordpress_publish": wp_publish_result,
                                                     "article_title": final_title_to_publish, # Use the edited title
                                                     "reader_type": extracted_reader_type # Use the extracted reader type
                                                 }
                                                 try:
                                                     # Check if update_article_history is defined before calling
                                                     if callable(update_article_history):
                                                          print("\ndf_kiji DataFrame と update_article_history 関数が見つかりました。履歴更新関数を呼び出します。")
                                                          # Call the update_article_history function and update the global df_kiji
                                                          # Pass the global df_kiji and update it in place
                                                          global df_kiji # Declare df_kiji as global to modify it
                                                          df_kiji = update_article_history(simplified_publishing_results_for_append, df_kiji)
                                                          print("\nグローバル変数 df_kiji が更新されました。")
                                                          # Optional: Display the last added row
                                                          if not df_kiji.empty:
                                                              print("\n--- df_kiji に追記された行 ---")
                                                              display(df_kiji.iloc[-1:])

                                                     else:
                                                          print("エラー: update_article_history 関数が定義されていません。履歴の自動更新はスキップされました。")
                                                 except Exception as e:
                                                     print(f"記事履歴の自動更新中に予期せぬエラーが発生しました: {e}")
                                             else:
                                                  print("警告: df_kiji DataFrame がグローバルスコープで見つかりません。履歴の自動更新はスキップされました。")


                                         elif wp_publish_result: # Handle cases where publish_to_wordpress returned a result but status is not success
                                              print("\nWordPress投稿は成功しませんでした。履歴の自動更新はスキップされました。")

                                         # --- Attempt X posting if WordPress publish was successful and URL exists ---
                                         if wp_publish_result and wp_publish_result.get("status") == "success":
                                             wordpress_article_url = wp_publish_result.get("url")
                                             if wordpress_article_url:
                                                 print("\nWordPress投稿が成功しました。X (旧Twitter) への投稿を試みます...")
                                                 # Prepare a short message for X
                                                 x_message = f"新着記事「{final_title_to_publish}」を公開しました！ぜひご覧ください！ {wordpress_article_url}"
                                                 print(f"Prepared X message: {x_message}")

                                                 # Check for X API credentials
                                                 consumer_key = os.getenv("X_CONSUMER_KEY")
                                                 consumer_secret = os.getenv("X_CONSUMER_SECRET")
                                                 access_token = os.getenv("X_ACCESS_TOKEN")
                                                 access_token_secret = os.getenv("X_ACCESS_TOKEN_SECRET")

                                                 if all([consumer_key, consumer_secret, access_token, access_token_secret]):
                                                      # Check if post_to_x is defined
                                                      if 'post_to_x' in globals() and callable(post_to_x):
                                                         try:
                                                              x_post_result = post_to_x(article_url=wordpress_article_url, message=x_message)
                                                              print("\n--- X Post Result ---")
                                                              print(json.dumps(x_post_result, indent=2, ensure_ascii=False))
                                                         except Exception as e:
                                                              print(f"X投稿中にエラーが発生しました: {e}")
                                                      else:
                                                           print("エラー: post_to_x 関数が定義されていません。X投稿をスキップします。")
                                                 else:
                                                     print("\nX API認証情報が設定されていません。Xへの自動投稿はスキップされました。")
                                             else:
                                                  print("WordPress投稿は成功しましたが、記事URLが取得できませんでした。X投稿をスキップします。")
                                         else:
                                             print("\nWordPress投稿が成功しなかったため、X投稿をスキップします。")


                                 except Exception as e:
                                      print(f"WordPressまたはX投稿中にエラーが発生しました: {e}")

                             else:
                                 print("\nWordPress認証情報が設定されていません。WordPressおよびXへの自動投稿はスキップされました。")
                                 print("上記の記事本文をコピーして、手動でWordPressに貼り付けてください。")


                    publish_wp_button.on_click(on_publish_wp_button_clicked)
                    display(publish_wp_button)


            else:
                print("\n警告: 記事本文が生成されませんでした。Assistantからの応答を確認してください（上記DEBUG出力参照）。") # More specific message
                if style == 'record': # Add a note for WordPress if no body generated
                     print("WordPressへの自動投稿は、記事本文が生成されなかったためスキップされました。")


    # ボタンにハンドラーを割り当て
    note_narrative_button.on_click(on_generate_button_clicked)
    wp_record_button.on_click(on_generate_button_clicked)


    # ウィジェットをVBoxに格納して表示
    ui_elements = widgets.VBox([
        further_instructions_input, # 追加指示入力欄を残す
        widgets.HBox([note_narrative_button, wp_record_button]) # 2つのボタンを横並びにする
    ])

    # VBoxとoutput_areaをまとめて表示
    display(widgets.VBox([ui_elements, output_area]))

print("\nCorrected typo in textwrap.dedent.")
print("Added more specific warning if no article body is generated.")
print("MODIFIED article_writer_ui function signature to accept article_title.")

"""# 9892eda2"""

# 記事本文生成のためのUIを表示する関数（変更あり）
import ipywidgets as widgets
from IPython.display import display, clear_output
import re # reをインポートして読者タイプを抽出

def article_writer_ui(template_text, record_text, kadai_id, article_title):
    """
    ユーザーに本文生成スタイルを選択させ、記事本文生成関数を呼び出すUI。
    Args:
        template_text (str): テンプレート生成アシスタントからの出力。
        record_text (str): 対象課題の整形済み指導記録全文。
        kadai_id (str): 対象課題の課題ID。
        article_title (str): ユーザーが選択/入力した記事タイトル。
    """
    print("\n---- 記事本文生成UI ----")
    print(f"使用する記事タイトル: {article_title}")
    print("生成したい記事のスタイルを選択してください。")

    # テキストエリアは、本文生成のための「追加の詳細指示」として残す
    further_instructions_input = widgets.Textarea(
        value='',
        placeholder='記事本文生成のための追加の詳細指示を入力してください（例: 特定の点をさらに強調する、特定の表現を避けるなど）',
        description='追加指示:',
        disabled=False,
        layout=widgets.Layout(width='80%', height='100px')
    )

    # スタイル選択ボタンを配置
    note_narrative_button = widgets.Button(description='Note用記事生成（ナラティブ）', button_style='info')
    wp_record_button = widgets.Button(description='WordPress記事生成（記録風）', button_style='success')

    output_area = widgets.Output()

    # 読者タイプをテンプレートテキストから抽出
    reader_type_match = re.search(r"【読者タイプ】:\s*(.+?)向け", template_text)
    extracted_reader_type = reader_type_match.group(1).strip() if reader_type_match else "不明"
    print(f"抽出された読者タイプ: {extracted_reader_type}")


    # ボタンクリック時のハンドラ関数
    def on_generate_button_clicked(b):
        style = 'narrative' if b.description == 'Note用記事生成（ナラティブ）' else 'record'
        print(f"DEBUG: {b.description} clicked. Style: {style}") # DEBUG

        with output_area:
            clear_output(wait=True)
            print(f"\n選択されたスタイル '{style}' で記事本文を生成中です...")

            # article_writer 関数を呼び出す際に、スタイルと確定したタイトル、抽出した読者タイプを渡す
            # further_instructions_input の内容は、現在のarticle_writerのprompt構造では使用されません。
            # もし追加指示も盛り込みたい場合は、article_writerのpromptをさらに修正する必要があります。
            # 今回のタスクの主旨はスタイル指定とタイトル使用なので、ここでは追加指示は無視します。
            # Ensure all required arguments are passed to article_writer
            article_writer(template_text, record_text, kadai_id, article_title, style, extracted_reader_type)

            print("\n記事本文生成処理が完了しました（上記参照）。")


    # ボタンにハンドラを割り当て
    note_narrative_button.on_click(on_generate_button_clicked)
    wp_record_button.on_click(on_generate_button_clicked)


    # ウィジェットをVBoxに格納して表示
    ui_elements = widgets.VBox([
        further_instructions_input, # 追加指示入力欄を残す
        widgets.HBox([note_narrative_button, wp_record_button]) # 2つのボタンを横並びにする
    ])

    # VBoxとoutput_areaをまとめて表示
    display(widgets.VBox([ui_elements, output_area]))

print("\nThe `article_writer_ui` function has been updated to ensure the click handlers correctly pass all required arguments to `article_writer`.")

"""# 4e1afda4"""

# Helper function to publish an article to WordPress
# Ensure you have WORDPRESS_URL, WORDPRESS_USER, and WORDPRESS_PASSWORD set as environment variables or Colab secrets.
# Requires 'requests' library: !pip install requests

import requests
import json
import base64 # Needed for image upload
import os # Needed for os.path.basename

# Define the local category slug mapping again for use in this cell
category_slug_mapping = {
    "チームと場のデザイン": "team-design",
    "フォーム改善・身体操作": "form-movement",
    "メンタルと自己認識": "mental-awareness",
    "判断・選択・状況理解": "decision-making",
    "問いと気づきの技術": "awareness-skills",
    "実践レポート・対話の記録": "dialogue-log",
    "成長の理論と実践": "growth-practice",
    "継続と習慣づくり": "habit-building",
    "親と子・保護者の関わり": "parenting-support",
    "試合対応力・緊張対策": "match-readiness"
}
print("DEBUG: Loaded local category slug mapping in cell 4e1afda4.")


# Helper function to get category ID from name using the WordPress API
# Ensure this function is defined and uses the provided credentials
# This requires the WordPress REST API endpoint for categories (usually /wp-json/wp/v2/categories)
def get_category_id_by_name(wordpress_url, username, password, category_name):
    """
    Gets the ID of a WordPress category by its name.

    Args:
        wordpress_url (str): The base URL of the WordPress site.
        username (str): The WordPress username.
        password (str): The WordPress application password.
        category_name (str): The name of the category to find.

    Returns:
        int or None: The category ID if found, otherwise None.
    """
    if not wordpress_url or not username or not password or not category_name or category_name == "カテゴリ不明":
        print("DEBUG (get_category_id_by_name): Missing required info or category is 'カテゴリ不明'. Skipping API call.")
        return None # Cannot get ID without necessary info or for placeholder

    # Construct the API endpoint for categories
    api_url = f"{wordpress_url.rstrip('/')}/wp-json/wp/v2/categories"
    auth = requests.auth.HTTPBasicAuth(username, password)

    try:
        # Make a GET request to filter categories by name
        # The 'slug' parameter is more reliable for searching than 'name'
        # We need to convert the category name to its slug first using the mapping
        category_slug = category_slug_mapping.get(category_name)

        if not category_slug:
            print(f"警告 (get_category_id_by_name): カテゴリー名 '{category_name}' に対応するスラッグが category_slug_mapping に見つかりません。")
            return None # Cannot find category if slug is not mapped


        print(f"DEBUG (get_category_id_by_name): Attempting to get category ID for slug: '{category_slug}'")
        response = requests.get(api_url, auth=auth, params={'slug': category_slug})

        if response.status_code == 200:
            categories = response.json()
            if categories:
                # The API returns a list, even if only one matches the slug.
                # The first item should be the correct category.
                category_id = categories[0]['id']
                print(f"DEBUG (get_category_id_by_name): Found category ID {category_id} for '{category_name}' (slug: {category_slug}).")
                return category_id
            else:
                print(f"警告 (get_category_id_by_name): WordPressでカテゴリー '{category_name}' (スラッグ: {category_slug}) が見つかりませんでした。")
                return None
        else:
            print(f"エラー (get_category_id_by_name): カテゴリー情報取得API呼び出しに失敗しました。ステータスコード: {response.status_code}, 応答: {response.text}")
            return None

    except requests.exceptions.RequestException as e:
        print(f"エラー (get_category_id_by_name): カテゴリー情報取得中にネットワークまたはAPIエラーが発生しました: {e}")
        return None
    except Exception as e:
        print(f"エラー (get_category_id_by_name): カテゴリー情報取得中に予期せぬエラーが発生しました: {e}")
        print(traceback.format_exc())
        return None


# Helper function to upload an image to WordPress media library
def upload_image_to_wordpress(wordpress_url, username, password, image_url):
    """
    Uploads an image from a URL to the WordPress media library.

    Args:
        wordpress_url (str): The base URL of the WordPress site.
        username (str): The WordPress username.
        password (str): The WordPress application password.
        image_url (str): The URL of the image to download and upload.

    Returns:
        dict or None: A dictionary containing the uploaded image's ID and URL on success, otherwise None.
                      Example: {'id': 123, 'url': 'http://yourwp.com/wp-content/uploads/image.jpg'}
    """
    if not wordpress_url or not username or not password or not image_url:
        print("DEBUG (upload_image_to_wordpress): Missing required information for image upload.")
        return {"status": "skipped", "message": "Missing required information for image upload."}

    # Construct the API endpoint for media
    api_url = f"{wordpress_url.rstrip('/')}/wp-json/wp/v2/media"
    auth = requests.auth.HTTPBasicAuth(username, password)

    try:
        # 1. Download the image from the URL
        print(f"DEBUG (upload_image_to_wordpress): Downloading image from URL: {image_url[:100]}...")
        image_response = requests.get(image_url, stream=True) # Use stream=True for potentially large files
        image_response.raise_for_status() # Raise an exception for bad status codes (4xx or 5xx)

        # Determine filename from URL or use a default
        # Simple approach: take the last part of the URL path
        filename = os.path.basename(image_url)
        # If filename is empty or looks like just a hash, try to find a content-disposition header
        if not filename or len(filename) < 5 or '.' not in filename:
             # Check Content-Disposition header
             if 'Content-Disposition' in image_response.headers:
                 cd = image_response.headers['Content-Disposition']
                 fname_match = re.search(r'filename="(.+)"', cd)
                 if fname_match:
                     filename = fname_match.group(1)
                     print(f"DEBUG (upload_image_to_wordpress): Found filename from Content-Disposition: {filename}")
             # Fallback to a generic name if still no good filename
             if not filename or len(filename) < 5 or '.' not in filename:
                 # Try to infer extension from Content-Type
                 content_type = image_response.headers.get('Content-Type', '').lower()
                 ext = '.jpg' # Default extension
                 if 'png' in content_type:
                      ext = '.png'
                 elif 'gif' in content_type:
                      ext = '.gif'
                 elif 'jpeg' in content_type:
                      ext = '.jpg' # or .jpeg
                 filename = f"uploaded_image_{int(time.time())}{ext}"
                 print(f"DEBUG (upload_image_to_wordpress): Using generated filename: {filename}")

        # 2. Prepare the image data for upload
        # Read image data in chunks if streaming
        image_data = b''
        for chunk in image_response.iter_content(chunk_size=8192):
            image_data += chunk

        if not image_data:
             print("エラー (upload_image_to_wordpress): ダウンロードした画像データが空です。")
             return {"status": "failure", "message": "Downloaded image data is empty."}

        # 3. Upload the image to WordPress media library
        print(f"DEBUG (upload_image_to_wordpress): Uploading image '{filename}' to WordPress...")
        headers = {
            'Content-Type': image_response.headers.get('Content-Type', 'image/jpeg'), # Use downloaded image's content type or default
            'Content-Disposition': f'attachment; filename="{filename}"'
        }

        upload_response = requests.post(api_url, headers=headers, data=image_data, auth=auth)

        if upload_response.status_code == 201: # 201 Created indicates success
            media_info = upload_response.json()
            uploaded_image_id = media_info.get('id')
            uploaded_image_url = media_info.get('source_url')
            print(f"DEBUG (upload_image_to_wordpress): Image uploaded successfully. ID: {uploaded_image_id}, URL: {uploaded_image_url}")
            return {"status": "success", "id": uploaded_image_id, "url": uploaded_image_url, "filename": filename}
        else:
            print(f"エラー (upload_image_to_wordpress): 画像アップロードAPI呼び出しに失敗しました。ステータスコード: {upload_response.status_code}, 応答: {upload_response.text}")
            return {"status": "failure", "message": f"Image upload API failed: Status {upload_response.status_code}, Response: {upload_response.text}"}

    except requests.exceptions.RequestException as e:
        print(f"エラー (upload_image_to_wordpress): 画像のダウンロードまたはアップロード中にネットワークまたはAPIエラーが発生しました: {e}")
        return {"status": "failure", "message": f"Network or API error during image handling: {e}"}
    except Exception as e:
        print(f"エラー (upload_image_to_wordpress): 画像アップロード処理中に予期せぬエラーが発生しました: {e}")
        print(traceback.format_exc())
        return {"status": "failure", "message": f"Unexpected error during image upload: {e}"}


# --- Main Publish Function ---
# Modified to accept images_to_upload list
def publish_to_wordpress(wordpress_url, username, password, title, content, tags=None, categories=None, slug=None, images_to_upload=None):
    """
    Publishes an article (or updates) to WordPress via the REST API.

    Args:
        wordpress_url (str): The base URL of the WordPress site.
        username (str): The WordPress username.
        password (str): The WordPress application password.
        title (str): The title of the article.
        content (str): The HTML content of the article.
        tags (list, optional): A list of tag names (strings). Defaults to None.
        categories (list, optional): A list of category names (strings). Defaults to None.
        slug (str, optional): The URL slug for the post. Defaults to None (WP generates from title).
        images_to_upload (list, optional): A list of dictionaries containing image data (url, filename, status)
                                          for images to upload and attach. Defaults to None.

    Returns:
        dict: A dictionary containing the status of the publish attempt ('success' or 'failure')
              and relevant information like the post ID, URL, and any error messages.
              Includes 'uploaded_images' list with results for each image.
    """
    api_url = f"{wordpress_url.rstrip('/')}/wp-json/wp/v2/posts"
    auth = requests.auth.HTTPBasicAuth(username, password)

    # Prepare payload
    payload = {
        'title': title,
        'content': content,
        'status': 'draft'  # Publish as draft
    }

    if slug:
        payload['slug'] = slug

    # --- Handle Categories ---
    category_ids = []
    if categories:
        print(f"DEBUG (publish_to_wordpress): Processing categories: {categories}")
        for cat_name in categories:
            # Get the category ID using the helper function
            cat_id = get_category_id_by_name(wordpress_url, username, password, cat_name)
            if cat_id is not None:
                category_ids.append(cat_id)
        if category_ids:
            payload['categories'] = category_ids
            print(f"DEBUG (publish_to_wordpress): Added category IDs to payload: {category_ids}")
        else:
            print("警告 (publish_to_wordpress): 指定されたカテゴリー名に対応するIDが見つかりませんでした。カテゴリーなしで投稿します。")

    # --- Handle Tags ---
    # WordPress API for tags requires tag IDs, not names, for direct assignment.
    # To assign by name, we'd need to fetch tag IDs first, similar to categories.
    # A simpler approach for now is to include tags in the content or let WP auto-create/assign.
    # The API 'tags' parameter expects an array of tag IDs.
    # For simplicity, we won't assign tags via the API 'tags' parameter in this version.
    # Tags suggested by the Assistant will be added as text in the body or handled manually in WP.
    # If direct tag assignment is needed, a similar lookup function to get_category_id_by_name is required.
    print("DEBUG (publish_to_wordpress): Tag assignment via API 'tags' parameter is not implemented in this version.")
    # if tags:
    #    # Need to implement logic to get tag IDs from names
    #    tag_ids = [] # Placeholder
    #    if tag_ids:
    #        payload['tags'] = tag_ids


    # --- Handle Images ---
    # Process images to upload and attach to the post
    uploaded_images_results = []
    if images_to_upload:
        print(f"DEBUG (publish_to_wordpress): Processing {len(images_to_upload)} images for upload.")
        # Iterate through the list of images provided
        for i, img_info in enumerate(images_to_upload):
            image_url = img_info.get('url')
            if image_url:
                print(f"DEBUG (publish_to_wordpress): Attempting to upload image {i+1} from URL: {image_url[:100]}...")
                # Call the helper function to upload the image
                upload_result = upload_image_to_wordpress(wordpress_url, username, password, image_url)
                uploaded_images_results.append(upload_result) # Store the result for this image

                if upload_result and upload_result.get("status") == "success" and upload_result.get("id"):
                    # If image upload was successful, add its ID to the payload for association
                    # Note: Direct image association via 'featured_media' or embedding in content
                    # might be needed depending on how the image should appear.
                    # 'featured_media' sets the post thumbnail.
                    # Embedding in content requires adding the image HTML tag with the uploaded image URL.

                    # Let's assume for now we want to add the *first* successfully uploaded image as featured media
                    if 'featured_media' not in payload and upload_result.get("id"):
                        payload['featured_media'] = upload_result.get("id")
                        print(f"DEBUG (publish_to_wordpress): Set featured_media to uploaded image ID: {upload_result.get('id')}")

                    # To embed images in the content, the generated content HTML would need to be modified
                    # to include <img src="..."> tags pointing to the uploaded image URLs.
                    # This requires modifying the 'content' field AFTER image upload.
                    # For simplicity in this version, we'll only set featured_media automatically.
                    # Embedding images would require a more complex content manipulation step.
                    # A note to the user might be needed that images need to be manually inserted into the body in WP.
                    print("警告 (publish_to_wordpress): 画像はメディアライブラリにアップロードされ、最初の成功画像はアイキャッチ画像として設定されます。記事本文への挿入はWordPress側で手動で行う必要があります。")

            else:
                print(f"警告 (publish_to_wordpress): 画像 {i+1} のURLがありません。アップロードをスキップします。")
                uploaded_images_results.append({"status": "skipped", "message": "Image URL is missing."})
        print("DEBUG (publish_to_wordpress): Finished processing images for upload.")
    else:
        print("DEBUG (publish_to_wordpress): No images provided for upload.")


    print(f"DEBUG (publish_to_wordpress): Publishing payload: {json.dumps(payload, indent=2, ensure_ascii=False)}")

    # --- Make the API Request to Create/Update Post ---
    try:
        print("DEBUG (publish_to_wordpress): Making POST request to WordPress API...")
        response = requests.post(api_url, json=payload, auth=auth)

        if response.status_code == 201: # 201 Created indicates successful post creation
            post_info = response.json()
            post_id = post_info.get('id')
            post_link = post_info.get('link') # This is usually the canonical URL
            post_slug = post_info.get('slug')
            print(f"DEBUG (publish_to_wordpress): WordPress post created successfully. ID: {post_id}, URL: {post_link}, Slug: {post_slug}")
            return {
                "status": "success",
                "message": "Article published as draft successfully.",
                "id": post_id,
                "url": post_link,
                "slug": post_slug,
                "uploaded_images": uploaded_images_results # Include image upload results
            }
        else:
            print(f"エラー (publish_to_wordpress): WordPress投稿API呼び出しに失敗しました。ステータスコード: {response.status_code}, 応答: {response.text}")
            return {
                "status": "failure",
                "message": f"WordPress API failed: Status {response.status_code}, Response: {response.text}",
                "uploaded_images": uploaded_images_results # Include image upload results
            }

    except requests.exceptions.RequestException as e:
        print(f"エラー (publish_to_wordpress): WordPress投稿中にネットワークまたはAPIエラーが発生しました: {e}")
        return {
            "status": "failure",
            "message": f"Network or API error during WordPress publish: {e}",
            "uploaded_images": uploaded_images_results # Include image upload results
        }
    except Exception as e:
        print(f"エラー (publish_to_wordpress): WordPress投稿処理中に予期せぬエラーが発生しました: {e}")
        print(traceback.format_exc())
        return {
            "status": "failure",
            "message": f"Unexpected error during WordPress publish: {e}",
            "uploaded_images": uploaded_images_results # Include image upload results
        }

# Define get_wordpress_post_url_by_id function here if it's not defined elsewhere
# (It was called in cell 6b45381f, so it needs to be defined in an earlier cell or here)
# Assuming it's defined in another helper cell. If not, it needs to be added.

# Define format_for_note function here if it's not defined elsewhere
# (It was called in cell 409411f5, so it needs to be defined in an earlier cell or here)
# Assuming it's defined in another helper cell. If not, it needs to be added.

# Define post_to_x function here if it's not defined elsewhere
# (It was called in cell 6b45381f, so it needs to be defined in an earlier cell or here)
# Assuming it's defined in another helper cell. If not, it needs to be added.

# Define update_article_history function here if it's not defined elsewhere
# (It was called in cell 6b45381f, so it needs to be defined in an earlier cell or here)
# Assuming it's defined in another helper cell. If not, it needs to be added.

# Define parse_player_id_with_grade function here if it's not defined elsewhere
# (It was mentioned in the comments of cell 6b45381f, suggesting it's a dependency)
# Assuming it's defined in another helper cell. If not, it needs to be added.

""" # 443e98f6"""

import gspread
import pandas as pd
from google.auth import default
import datetime
# Ensure gspread.utils is accessible
import gspread.utils


def update_article_history(publishing_results: dict, df_kiji: pd.DataFrame, spreadsheet_name: str = "指導DB", worksheet_name: str = "記事履歴DB") -> pd.DataFrame:
    """
    Updates the df_kiji DataFrame and the Google Sheet with article publishing results.

    Args:
        publishing_results (dict): The results dictionary from automated_article_publishing_workflow.
        df_kiji (pd.DataFrame): The DataFrame for the article history DB (記事履歴DB).
        spreadsheet_name (str): The name of the Google Spreadsheet.
        worksheet_name (str): The name of the worksheet for article history.

    Returns:
        pd.DataFrame: The updated df_kiji DataFrame.
    """
    kadai_id = publishing_results.get('kadai_id')
    if not kadai_id:
        print("Error: publishing_results dictionary does not contain 'kadai_id'. Cannot update history.")
        return df_kiji # Return original DataFrame if Kadai ID is missing

    print(f"--- Updating article history for Kadai ID: {kadai_id} ---")

    # Find the row in df_kiji for the current Kadai ID, or prepare a new row
    # Assuming '課題ID' is the unique identifier in df_kiji
    target_row_index = df_kiji[df_kiji['課題ID'] == kadai_id].index

    if target_row_index.empty:
        print(f"Warning: Kadai ID {kadai_id} not found in df_kiji. Appending a new row.")
        # Prepare a new row dictionary with initial data
        new_row_data = {'課題ID': kadai_id}
        # Add other essential columns if they are not automatically handled by gspread append
        # Based on df_kiji structure: '記事タイトル', '記事本文', '公開日', '公開URL', '視点', 'フェーズ', 'テンプレ生成元あり？', '関連課題', 'テンプレート', '最終記録日（記事化ベース）', 'ロールアップ', '記事化ステータス', '読者タイプ', '作成日'
        # Initialize potentially missing columns with default values
        for col in ['記事タイトル', '記事本文', '公開日', '公開URL', '視点', 'フェーズ', 'テンプレ生成元あり？', '関連課題', 'テンプレート', '最終記録日（記事化ベース）', 'ロールアップ', '記事化ステータス', '読者タイプ', '作成日']:
             if col not in new_row_data:
                 new_row_data[col] = '' # Use empty string or appropriate default

        # Append the new row to the DataFrame
        # Ensure column order matches the original df_kiji or is handled by gspread
        # Use pd.concat to append a new row and ensure the DataFrame structure is maintained
        # Create a DataFrame from the new row data, ensuring columns are in the same order as df_kiji
        new_row_df = pd.DataFrame([new_row_data], columns=df_kiji.columns)
        df_kiji_updated = pd.concat([df_kiji, new_row_df], ignore_index=True)

        target_row_index = df_kiji_updated[df_kiji_updated['課題ID'] == kadai_id].index
        print(f"Added new row for Kadai ID {kadai_id} at index {target_row_index[0]}.")
    else:
         print(f"Found existing row for Kadai ID {kadai_id} at index {target_row_index[0]}. Updating.")
         df_kiji_updated = df_kiji.copy() # Work on a copy to avoid modifying the original df directly before gspread update


    # Get the row index for Google Sheet update (gspread is 0-indexed, pandas is 0-indexed)
    # We need the actual row number in the sheet, which is pandas index + 2 (1 for 0-index, 1 for header row)
    sheet_row_index = target_row_index[0] + 2


    # Update DataFrame row with publishing results
    current_time = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    # Update '記事化ステータス' based on overall status
    overall_status = publishing_results.get('overall_status', 'unknown')
    if overall_status == 'success':
        df_kiji_updated.loc[target_row_index, '記事化ステータス'] = '公開完了'
    elif overall_status == 'partial_success':
         df_kiji_updated.loc[target_row_index, '記事化ステータス'] = '一部公開成功'
    else:
         df_kiji_updated.loc[target_row_index, '記事化ステータス'] = '公開失敗'


    # Update URL and Public Date/Time based on successful platforms
    # Prioritize WordPress URL if available and successful for '公開URL' and '公開日'
    wordpress_publish_result = publishing_results.get("wordpress_publish", {})
    if wordpress_publish_result.get("status") == "success":
        wp_url = wordpress_publish_result.get("url")
        if wp_url:
            df_kiji_updated.loc[target_row_index, '公開URL'] = wp_url
            # Set '公開日' to current time if it's empty or if WordPress was the primary success
            if pd.isna(df_kiji_updated.loc[target_row_index, '公開日']) or df_kiji_updated.loc[target_row_index, '公開日'] == '':
                 df_kiji_updated.loc[target_row_index, '公開日'] = current_time


    # You could add logic here for other platforms if their APIs were functional
    # e.g., if note_publish_result.get("status") == "success": ...


    # You could also update other fields if they were part of the publishing_results
    # e.g., df_kiji_updated.loc[target_row_index, '記事タイトル'] = publishing_results.get('title', df_kiji_updated.loc[target_row_index, '記事タイトル'])


    # --- Update Google Sheet ---
    try:
        creds, _ = default()
        gc = gspread.authorize(creds)
        sh = gc.open(spreadsheet_name)
        ws = sh.worksheet(worksheet_name)

        # Get all header values from the sheet to map DataFrame columns to sheet columns
        header_values = ws.row_values(1)
        header_map = {col_name: header_values.index(col_name) for col_name in header_values}

        # Prepare values to update for the specific row
        # Iterate through columns that were updated in the DataFrame
        # Ensure values match the sheet's column order using header_map
        values_to_update = [''] * len(header_values) # Initialize with empty strings or existing sheet values if needed

        # Get the row data from the *updated* DataFrame copy
        updated_row_data = df_kiji_updated.loc[target_row_index].iloc[0]

        for col_name, value in updated_row_data.items():
             if col_name in header_map:
                 # Convert datetime objects or NaT to string representation if necessary
                 if pd.isna(value):
                     values_to_update[header_map[col_name]] = ''
                 elif isinstance(value, datetime.datetime):
                      values_to_update[header_map[col_name]] = value.strftime('%Y-%m-%d %H:%M:%S') # Or appropriate format
                 else:
                     values_to_update[header_map[col_name]] = str(value)


        # Update the specific row in the Google Sheet
        # Construct the range string, e.g., 'A5:Z5' for row 5
        # Use gspread.utils.colrow_to_a1 correctly
        end_column_letter = gspread.utils.colrow_to_a1(1, len(header_values))[0] # Get the letter for the last column (col_index is 1-based)
        update_range = f'A{sheet_row_index}:{end_column_letter}{sheet_row_index}'

        print(f"Updating Google Sheet range: {update_range} with data: {values_to_update}")
        ws.update(update_range, [values_to_update])
        print(f"Google Sheet updated successfully for Kadai ID: {kadai_id}.")


    except Exception as e:
        print(f"Error updating Google Sheet for Kadai ID {kadai_id}: {e}")
        # Even if sheet update fails, return the updated DataFrame
        return df_kiji_updated

    # Return the updated DataFrame
    return df_kiji_updated


# --- Example Usage (assuming automated_article_publishing_workflow was run) ---
# Use the 'publishing_results' variable from the previous cell's example execution.
# Check if 'publishing_results' exists and has data before attempting to update.

# if 'publishing_results' in locals() and publishing_results:
#      print("\n--- Running update_article_history with publishing results ---")
#      # Call the function and re-assign the global df_kiji with the returned DataFrame
#      df_kiji = update_article_history(publishing_results, df_kiji)
#      print("\nGlobal df_kiji variable has been updated.")
#      # Display the updated row(s) in the DataFrame (optional)
#      # display(df_kiji[df_kiji['課題ID'] == publishing_results['kadai_id']])
# else:
#      print("\nSkipping update_article_history: No publishing results available from the previous step.")

print("\nThe `update_article_history` function is defined and corrected to return the updated DataFrame.")
print("This function updates the df_kiji DataFrame and the Google Sheet based on publishing results.")

# Re-run the update with the simplified results from the previous step
# Ensure simplified_publishing_results and df_kiji are available
if 'simplified_publishing_results' in locals() and 'df_kiji' in globals():
    print("\n--- Re-running update_article_history with simplified results ---")
    try:
        df_kiji = update_article_history(simplified_publishing_results, df_kiji)
        print("\nGlobal df_kiji variable has been updated after re-running update.")
        # Optional: Display the updated row(s)
        updated_kadai_id = simplified_publishing_results.get('kadai_id')
        if updated_kadai_id and updated_kadai_id != 'Unknown ID for Update':
             print(f"\n--- Updated row for Kadai ID: {updated_kadai_id} in df_kiji (after re-run) ---")
             display(df_kiji[df_kiji['課題ID'] == updated_kadai_id])

    except Exception as e:
         print(f"Error calling update_article_history after re-run: {e}")
else:
     print("\nSkipping re-run of update_article_history: Required variables not available.")

"""# cdc56a4f"""

import os

# Check if Google Drive is mounted
print(f"Is Google Drive mounted at /content/drive? {os.path.exists('/content/drive')}")
print(f"Content of /content/drive/MyDrive: {os.listdir('/content/drive/MyDrive') if os.path.exists('/content/drive/MyDrive') else 'Directory not found'}")
print(f"Does /content/drive/MyDrive/APIKEY.env exist? {os.path.exists('/content/drive/MyDrive/APIKEY.env')}")

# Attempt to load dotenv again defensively (in case previous load failed)
from dotenv import load_dotenv
dotenv_path = "/content/drive/MyDrive/APIKEY.env"
if os.path.exists(dotenv_path):
    print(f"Attempting to load environment variables from {dotenv_path}")
    load_success = load_dotenv(dotenv_path)
    print(f"dotenv load success: {load_success}") # load_dotenv returns True if a file was loaded, False otherwise
else:
    print(f"dotenv file not found at {dotenv_path}")


# Check the values of the specific environment variables
wordpress_url = os.getenv("WORDPRESS_URL")
wordpress_user = os.getenv("WORDPRESS_USER")
wordpress_password = os.getenv("WORDPRESS_PASSWORD")

print(f"\nWORDPRESS_URL: {wordpress_url}")
print(f"WORDPRESS_USER: {wordpress_user}")
# SECURITY WARNING: Avoid printing sensitive passwords in plain text.
# print(f"WORDPRESS_PASSWORD: {wordpress_password}")
if wordpress_password:
    print("WORDPRESS_PASSWORD: ****** (Value is set)")
else:
    print("WORDPRESS_PASSWORD: None (Value is not set)")

print("\n環境変数の確認を完了しました。")

"""# f356e620"""

import gspread
import pandas as pd
from google.auth import default
import datetime
# Ensure gspread.utils is accessible
import gspread.utils
import re # Import re for URL pattern matching
import os # Import os to get WORDPRESS_URL
# No longer need requests, base64, unidecode here if using local mapping
# import requests
# import base64
# from unidecode import unidecode


def update_article_history(publishing_results: dict, df_kiji: pd.DataFrame, spreadsheet_name: str = "指導DB", worksheet_name: str = "記事履歴DB") -> pd.DataFrame:
    """
    Appends a new row to the df_kiji DataFrame and the Google Sheet with article publishing results.
    Always appends a new row instead of updating existing ones based on Kadai ID.
    Attempts to construct a friendly permalink using a local category name to slug mapping
    if the initial API result returns a ?p=ID format URL.

    Args:
        publishing_results (dict): The results dictionary from automated_article_publishing_workflow.
                                   Expected keys: 'kadai_id', 'overall_status', 'wordpress_publish' (dict with 'url', 'slug', 'categories' IDs),
                                   'article_title', 'reader_type', 'categories' (list of category names used for publishing).
        df_kiji (pd.DataFrame): The DataFrame for the article history DB (記事履歴DB).
        spreadsheet_name (str): The name of the Google Spreadsheet.
        worksheet_name (str: The name of the worksheet for article history.

    Returns:
        pd.DataFrame: The updated df_kiji DataFrame with the new row appended.
    """
    kadai_id = publishing_results.get('kadai_id')
    # Ensure we have a Kadai ID, although we are always appending
    if not kadai_id:
        print("Warning: publishing_results dictionary does not contain 'kadai_id'. Appending with 'Unknown ID'.")
        kadai_id = 'Unknown ID' # Use a placeholder if ID is missing


    print(f"--- Appending new article history record for Kadai ID: {kadai_id} ---")
    # DEBUG: Print the full publishing_results dictionary received
    print("DEBUG (update_article_history): publishing_results received:")
    print(json.dumps(publishing_results, indent=2, ensure_ascii=False))


    # Prepare data for the new row, including only the specified columns
    # Extract necessary information from publishing_results
    article_title = publishing_results.get('article_title', '') # Assuming title is in results
    extracted_reader_type = publishing_results.get('reader_type', '') # Assuming reader_type is in results
    categories_used_names = publishing_results.get('categories', []) # Get list of category names used for publishing


    # Get URL, Slug, and assigned Category IDs from successful WordPress publish result
    wordpress_publish_result = publishing_results.get("wordpress_publish", {})
    api_provided_url = wordpress_publish_result.get("url", '') # URL provided by WP API (might be ?p=ID)
    post_slug = wordpress_publish_result.get("slug", '') # Slug returned by WP API (should be the one we specified)
    wp_status = wordpress_publish_result.get("status", "unknown")
    wp_assigned_category_ids = wordpress_publish_result.get('categories', []) # Category IDs assigned by WP (for info/debug)


    # Determine the URL to use for '公開URL'
    public_url = api_provided_url # Default to the URL provided by the API


    # --- Local Category Name to Slug Mapping ---
    # Provided by the user. Used to construct friendly permalink without extra API call.
    category_slug_mapping = {
        "チームと場のデザイン": "team-design",
        "フォーム改善・身体操作": "form-movement",
        "メンタルと自己認識": "mental-awareness",
        "判断・選択・状況理解": "decision-making",
        "問いと気づきの技術": "awareness-skills",
        "実践レポート・対話の記録": "dialogue-log", # Note: User's example used 'growth-practice' for this, mapping should reflect actual desired slug
        "成長の理論と実践": "growth-practice", # Note: User's example used 'growth-practice' for '実践レポート・対話の記録', check if mapping is correct
        "継続と習慣づくり": "habit-building",
        "親と子・保護者の関わり": "parenting-support",
        "試合対応力・緊張対策": "match-readiness"
        # Add other categories as needed
    }
    print("DEBUG (update_article_history): Using local category slug mapping.")
    print(json.dumps(category_slug_mapping, indent=2, ensure_ascii=False))


    # --- Attempt to construct a friendly permalink using local mapping ---
    # Conditions for construction:
    # 1. WP publish was successful.
    # 2. API provided URL is likely ?p=ID format.
    # 3. A post slug is available.
    # 4. Category names used for publishing are available (and we'll use the first one).
    # 5. WordPress base URL is available.
    wordpress_base_url = os.getenv("WORDPRESS_URL")


    if (wp_status == "success" and re.search(r'\?p=\d+', api_provided_url) and
        post_slug and categories_used_names and wordpress_base_url):

        print(f"DEBUG (update_article_history): Conditions met for friendly URL construction using local mapping.")
        print(f"DEBUG (update_article_history): API URL: '{api_provided_url}'")
        print(f"DEBUG (update_article_history): Post Slug: '{post_slug}'")
        print(f"DEBUG (update_article_history): Categories Used (Names): {categories_used_names}")
        print(f"DEBUG (update_article_history): WP Base URL: '{wordpress_base_url}'")


        # Get the first category name used for publishing
        first_category_name = categories_used_names[0]
        category_slug_from_mapping = category_slug_mapping.get(first_category_name)

        print(f"DEBUG (update_article_history): First category name used: '{first_category_name}'")
        print(f"DEBUG (update_article_history): Slug found in mapping: '{category_slug_from_mapping}'")


        # --- Construct the URL using the slug from the local mapping ---
        if category_slug_from_mapping:
            # Construct the URL: base_url/category_slug/post_slug/
            # Ensure base_url ends with a slash, and add trailing slash to slug segment and post slug
            base = wordpress_base_url.rstrip('/')
            cat_slug = category_slug_from_mapping.strip('/')
            post_s = post_slug.strip('/')

            constructed_url = f"{base}/{cat_slug}/{post_s}/"
            print(f"DEBUG (update_article_history): Constructed friendly URL (using mapped category slug '{category_slug_from_mapping}'): '{constructed_url}'")
            public_url = constructed_url # Use this constructed URL


        # --- Final check/Fallback ---
        # If after all attempts, the constructed URL is still the ?p=ID format (shouldn't happen
        # if construction was successful) or if construction failed, fall back to API provided.
        # A simple check: If the chosen public_url contains "?p=", and the original API URL was ?p=ID,
        # it likely means construction failed (e.g., category not in mapping). Fallback to API provided.
        if "?p=" in public_url and re.search(r'\?p=\d+', api_provided_url):
             print(f"DEBUG (update_article_history): Constructed public_url still contains '?p=' or mapping failed. Falling back to API provided URL: '{api_provided_url}'")
             public_url = api_provided_url # Fallback to the original API URL


    # Use current time as public date if WordPress publish was successful
    public_date = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S') if wp_status == "success" else ''

    # Create a dictionary for the new row with specified columns
    new_row_data = {
        '記事タイトル': article_title,
        '公開日': public_date,
        '公開URL': public_url, # Use the determined public_url (constructed or API provided)
        '課題ID': kadai_id,
        '読者タイプ': extracted_reader_type
        # Initialize other columns present in df_kiji with empty strings to match structure
    }

    # Ensure all columns from the original df_kiji are present in the new row data
    # Initialize missing columns with empty strings to match the DataFrame schema
    for col in df_kiji.columns:
        if col not in new_row_data:
            new_row_data[col] = ''

    # Create a DataFrame from the new row data, ensuring columns are in the same order as df_kiji
    new_row_df = pd.DataFrame([new_row_data], columns=df_kiji.columns)

    # Append the new row to the local DataFrame
    df_kiji_updated = pd.concat([df_kiji, new_row_df], ignore_index=True)
    print("New row appended to local df_kiji DataFrame.")


    # --- Append new row to Google Sheet ---
    try:
        creds, _ = default()
        gc = gspread.authorize(creds)
        sh = gc.open(spreadsheet_name)
        ws = sh.worksheet(worksheet_name)

        # Get all header values from the sheet to map DataFrame columns to sheet columns
        header_values = ws.row_values(1)
        # Create a mapping from header name to column index (0-based)
        header_map = {col_name: header_values.index(col_name) for col_name in header_values}

        # Prepare values to append for the new row based on header order
        values_to_append = [''] * len(header_values) # Initialize with empty strings

        # Populate values based on the new_row_data dictionary and header_map
        for col_name, value in new_row_data.items():
             if col_name in header_map:
                 # Convert datetime objects or NaT to string representation if necessary
                 if pd.isna(value):
                     values_to_append[header_map[col_name]] = ''
                 elif isinstance(value, datetime.datetime):
                      values_to_append[header_map[col_name]] = value.strftime('%Y-%m-%d %H:%M:%S') # Or appropriate format
                 else:
                     # Ensure values are strings and handle None/NaN explicitly
                     values_to_append[header_map[col_name]] = str(value) if value is not None and pd.notna(value) else ''


        # Append the new row to the Google Sheet
        print(f"Appending data to Google Sheet: {values_to_append}")
        ws.append_row(values_to_append)
        print(f"New row appended to Google Sheet for Kadai ID: {kadai_id}.")


    except Exception as e:
        print(f"Error appending new row to Google Sheet for Kadai ID {kadai_id}: {e}")
        # Even if sheet append fails, return the updated DataFrame
        return df_kiji_updated

    # Return the updated DataFrame
    return df_kiji_updated


# --- Example Usage (assuming automated_article_publishing_workflow was run) ---
# Use the 'publishing_results' variable from the previous cell's example execution.
# Check if 'publishing_results' exists and has data before attempting to update.

# if 'publishing_results' in locals() and publishing_results:
#      print("\n--- Running update_article_history with publishing results (Append Mode) ---")
#      # Call the function and re-assign the global df_kiji with the returned DataFrame
#      df_kiji = update_article_history(publishing_results, df_kiji)
#      print("\nGlobal df_kiji variable has been updated.")
#      # Display the last added row in the DataFrame (optional)
#      # if not df_kiji.empty:
#      #     display(df_kiji.iloc[-1:])
# else:
#      print("\nSkipping update_article_history (Append Mode): No publishing results available from the previous step.")

print("\nThe `update_article_history` function has been modified to always append a new row.")
print("It will include '記事タイトル', '公開日', '公開URL', '課題ID', and '読者タイプ'.")
print("It now attempts to construct a friendly URL using a local category name to slug mapping if the API returns a ?p=ID format.")


# Re-run the update with the simplified results from the previous step IF available and valid
# Ensure simplified_publishing_results and df_kiji are available
# The variable name is simplified_publishing_results_for_append in cell 246c7b8c
if 'simplified_publishing_results_for_append' in locals() and 'df_kiji' in globals():
    print("\n--- Re-running update_article_history with results (Append Mode) ---")
    try:
        # Call the update_article_history function with the existing dictionary and global df_kiji
        global df_kiji # Declare df_kiji as global to modify it
        df_kiji = update_article_history(simplified_publishing_results_for_append, df_kiji)
        print("\nGlobal df_kiji variable has been updated after re-running update (Append Mode).")
        # Optional: Display the last added row in the DataFrame
        if not df_kiji.empty:
            print("\n--- Last appended row in df_kiji ---")
            display(df_kiji.iloc[-1:])

    except Exception as e:
         print(f"Error calling update_article_history after re-run (Append Mode): {e}")
else:
     print("\nSkipping re-run of update_article_history (Append Mode): Required variables (simplified_publishing_results_for_append or df_kiji) not available from previous step.")

"""# cb05dfd8"""

# --- Function to trigger WordPress publishing logic directly ---
# This function encapsulates the core logic from on_publish_wp_button_clicked
# to bypass the ipywidgets button event system for debugging.

import ipywidgets as widgets
from IPython.display import display, clear_output
import textwrap
import os
import time
from openai import OpenAI
import json
import re
import traceback
import pandas as pd

def trigger_wordpress_publish_directly(kadai_id, template_text, record_text, article_title, edited_body, edited_tags_str, main_category, sub_category):
    """
    Directly triggers the WordPress publishing logic for debugging purposes.

    Args:
        kadai_id (str): The Kadai ID.
        template_text (str): The template text.
        record_text (str): The record text.
        article_title (str): The final article title.
        edited_body (str): The (potentially edited) article body text.
        edited_tags_str (str): The (potentially edited) comma-separated tags string.
        main_category (str): The extracted main category.
        sub_category (str): The extracted sub category.
    """
    print("\n--- 直接WordPress投稿トリガー ---")
    print(f"対象課題ID: {kadai_id}")
    print(f"使用するタイトル: {article_title}")

    # Create a temporary output area for this direct trigger
    output_area_direct_publish = widgets.Output()
    display(output_area_direct_publish)

    with output_area_direct_publish:
        clear_output(wait=True)
        print("直接WordPressに投稿しています...")

        # Replicate logic from on_publish_wp_button_clicked

        # Get potentially edited title, body, and tags
        final_title_to_publish = article_title # Use the provided title
        final_body_to_publish = edited_body # Use the provided body
        final_tags_to_publish_str = edited_tags_str # Use the provided tags string

        # Convert comma-separated tag string to a list of strings
        final_tags_list = [tag.strip() for tag in final_tags_to_publish_str.split(',') if tag.strip()]

        # Extract category names as a list (only main category for now)
        final_categories_list = [main_category] if main_category and main_category != "カテゴリ不明" else []
        if sub_category:
            final_categories_list.append(sub_category)

        if not final_title_to_publish or not final_body_to_publish:
            print("エラー: タイトルまたは本文が空です。投稿をスキップします。")
            return

        # Check for WordPress credentials and attempt publishing
        wordpress_url = os.getenv("WORDPRESS_URL")
        wordpress_user = os.getenv("WORDPRESS_USER")
        wordpress_password = os.getenv("WORDPRESS_PASSWORD")

        wp_publish_result = None # Initialize result variable

        if all([wordpress_url, wordpress_user, wordpress_password]):
            print("\nWordPress認証情報が見つかりました。WordPressへの投稿を試みます...")
            try:
                # Use the publish_to_wordpress function (assuming it's defined globally)
                if 'publish_to_wordpress' in globals() and callable(publish_to_wordpress):
                    wp_publish_result = publish_to_wordpress(
                        wordpress_url=wordpress_url,
                        username=wordpress_user,
                        password=wordpress_password,
                        title=final_title_to_publish,
                        content=final_body_to_publish,
                        tags=final_tags_list,
                        categories=final_categories_list
                    )
                    print("\n--- WordPress Publish Result ---")
                    print(json.dumps(wp_publish_result, indent=2, ensure_ascii=False))

                    # --- Automatically call update_article_history if WordPress publish was successful ---
                    if wp_publish_result and wp_publish_result.get("status") == "success":
                        print("\nWordPress投稿が成功しました。記事履歴の自動更新を試みます...")

                        # Prepare the results dictionary for update_article_history (Append Mode)
                        simplified_publishing_results_for_append = {
                            "kadai_id": kadai_id, # Use the original kadai_id
                            "overall_status": wp_publish_result.get("status", "unknown"),
                            "wordpress_publish": wp_publish_result,
                            "article_title": final_title_to_publish,
                            # Need reader_type - derive from template_text or pass as arg
                            # For now, let's derive it here again for this function
                            "reader_type": re.search(r"【読者タイプ】:\s*(.+?)向け", template_text).group(1).strip() if re.search(r"【読者タイプ】:\s*(.+?)向け", template_text) else "不明"
                        }

                        try:
                            if 'df_kiji' in globals() and callable(update_article_history):
                                print("\ndf_kiji DataFrame と update_article_history 関数が見つかりました。履歴更新関数を呼び出します。")
                                global df_kiji
                                df_kiji = update_article_history(simplified_publishing_results_for_append, df_kiji)
                                print("\nグローバル変数 df_kiji が更新されました。")
                                if not df_kiji.empty:
                                    print("\n--- df_kiji に追記された行 ---")
                                    display(df_kiji.iloc[-1:])
                                else:
                                    print("\ndf_kiji DataFrame は空のため、追記された行を表示できません。")
                            else:
                                print("エラー: df_kiji DataFrame または update_article_history 関数がグローバルスコープで見つかりません。履歴の自動更新はスキップされました。")
                        except Exception as e:
                            print(f"記事履歴の自動更新中に予期せぬエラーが発生しました: {e}")
                            print(traceback.format_exc())

                    elif wp_publish_result:
                         print("\nWordPress投稿は成功しませんでした。履歴の自動更新はスキップされました。")

                    # Attempt X posting if WordPress publish was successful and URL exists
                    if wp_publish_result and wp_publish_result.get("status") == "success":
                        wordpress_article_url = wp_publish_result.get("url")
                        if wordpress_article_url:
                            print("\nWordPress投稿が成功しました。X (旧Twitter) への投稿を試みます...")
                            x_message = f"新着記事「{final_title_to_publish}」を公開しました！ぜひご覧ください！ {wordpress_article_url}"
                            print(f"Prepared X message: {x_message}")

                            consumer_key = os.getenv("X_CONSUMER_KEY")
                            consumer_secret = os.getenv("X_CONSUMER_SECRET")
                            access_token = os.getenv("X_ACCESS_TOKEN")
                            access_token_secret = os.getenv("X_ACCESS_TOKEN_SECRET")

                            if all([consumer_key, consumer_secret, access_token, access_token_secret]):
                                 if 'post_to_x' in globals() and callable(post_to_x):
                                    try:
                                         x_post_result = post_to_x(article_url=wordpress_article_url, message=x_message)
                                         print("\n--- X Post Result ---")
                                         print(json.dumps(x_post_result, indent=2, ensure_ascii=False))
                                    except Exception as e:
                                         print(f"X投稿中にエラーが発生しました: {e}")
                                         print(traceback.format_exc())
                                 else:
                                      print("エラー: post_to_x 関数が定義されていません。X投稿をスキップします。")
                            else:
                                print("\nX API認証情報が設定されていません。Xへの自動投稿はスキップされました。")
                        else:
                             print("WordPress投稿は成功しましたが、記事URLが取得できませんでした。X投稿をスキップします。")
                    else:
                        print("\nWordPress投稿が成功しなかったため、X投稿をスキップします。")


                else:
                     print("エラー: 'publish_to_wordpress' 関数が定義されていません。前のステップを確認してください。")
                     wp_publish_result = {"status": "failure", "message": "'publish_to_wordpress' function is not defined."}
            except Exception as e:
                 print(f"WordPressまたはX投稿中に予期せぬエラーが発生しました: {e}")
                 print(traceback.format_exc())
                 wp_publish_result = {"status": "failure", "message": f"An unexpected error occurred during WordPress publish: {e}"}

        else:
            print("\nWordPress認証情報が設定されていません。WordPressおよびXへの自動投稿はスキップされました。")
            print("上記の記事本文をコピーして、手動でWordPressに貼り付けてください。")
            wp_publish_result = {"status": "skipped", "message": "WordPress credentials not set."}


# --- Example of how to call the direct trigger function ---
# You need to manually get the values from the UI widgets *after* they are displayed and populated
# in cell 246c7b8c and pass them to this function.
# This is for debugging the publishing logic execution flow, not a permanent solution.

# To use this:
# 1. Run cell 246c7b8c to display the UI.
# 2. Manually copy the values from the UI text areas (edited_title_input, edited_body_input, edited_tags_input)
#    and the extracted categories (main_category, sub_category) and the selected_kadai_id, template_text, record_text
#    which should be available in global scope after running cell 246c7b8c.
# 3. Uncomment the function call below and replace the placeholder values with the actual values.
# 4. Run *this* cell. The output should appear below this cell.

# Example call (replace with actual variable names and values after running cell 246c7b8c):
# if 'article_generation_data' in globals() and 'edited_title_input' in locals() and 'edited_body_input' in locals() and 'edited_tags_input' in locals():
#     print("\n--- Calling trigger_wordpress_publish_directly ---")
#     try:
#         # Get values from UI widgets (assuming they are still accessible in the environment)
#         # This might be tricky depending on how ipywidgets are handled in the notebook state.
#         # You might need to manually copy the text from the UI and paste it here for testing.
#         # For a more robust test, you could try to access the widgets by their variable names
#         # if they are in global scope or passed correctly.

#         # Assuming the necessary variables are available from previous cell execution:
#         # selected_kadai_id = article_generation_data.get('kadai_id')
#         # selected_template_text = article_generation_data.get('template_text')
#         # selected_record_text = article_generation_data.get('record_text')
#         # final_article_title = article_generation_data.get('article_title') # This is the title before editing

#         # Need the *edited* values from the UI widgets.
#         # Accessing ipywidgets values from a different cell can be complex.
#         # The easiest way for debugging is to manually copy the text from the UI and paste it here.

#         # Example manual values (replace with actual content from UI):
#         # debug_kadai_id = selected_kadai_id
#         # debug_template_text = selected_template_text
#         # debug_record_text = selected_record_text
#         # debug_article_title = edited_title_input.value # Get value from the UI widget
#         # debug_edited_body = edited_body_input.value   # Get value from the UI widget
#         # debug_edited_tags_str = edited_tags_input.value # Get value from the UI widget
#         # debug_main_category = main_category # Get the extracted category
#         # debug_sub_category = sub_category # Get the extracted sub category


#         # Call the function with the values
#         # trigger_wordpress_publish_directly(
#         #     kadai_id=debug_kadai_id,
#         #     template_text=debug_template_text,
#         #     record_text=debug_record_text,
#         #     article_title=debug_article_title,
#         #     edited_body=debug_edited_body,
#         #     edited_tags_str=debug_edited_tags_str,
#         #     main_category=debug_main_category,
#         #     sub_category=debug_sub_category
#         # )
#         # print("\n--- Direct trigger execution finished ---")

#     except Exception as e:
#         print(f"\nエラー: 直接投稿トリガー関数の呼び出し中にエラーが発生しました: {e}")
#         print(traceback.format_exc())
# else:
#      print("\n直接投稿トリガー関数は定義されましたが、実行に必要なデータ（article_generation_dataやUIウィジェットの値）が揃っていません。")
#      print("セル 246c7b8c を実行してUIを表示し、必要であれば手動で値をコピーして、このセルの呼び出し部分を修正してから実行してください。")

print("\n`trigger_wordpress_publish_directly` 関数が定義されました。")
print("この関数は、UIボタンを介さずに直接WordPress投稿ロジックを実行するために使用できます。")
print("使用するには、上記のコメントアウト部分を解除し、UIウィジェットから取得した実際の値を引数に渡して実行してください。")

"""# 7ca952f8"""

# Note投稿用データ生成関数

import textwrap
import json
import os # Import os to get the WordPress URL
import pandas as pd # Import pandas to potentially access df_kiji for the URL
import re # Import re for URL pattern matching

def format_for_note(article_body: str, tags: list, wordpress_url: str = None, kadai_id: str = None, df_kiji: pd.DataFrame = None) -> str:
    """
    Formats the article body, tags, and a link for Note posting.

    Args:
        article_body (str): The generated article body (Markdown format is expected).
        tags (list): A list of tag strings (e.g., ['#tag1', '#tag2']).
        wordpress_url (str, optional): The base URL of the WordPress site. Defaults to None.
        kadai_id (str, optional): The Kadai ID of the article. Defaults to None.
        df_kiji (pd.DataFrame, optional): The DataFrame for the article history DB. Defaults to None.

    Returns:
        str: The formatted text ready for Note posting.
    """
    note_output = ""

    # Add article body
    note_output += textwrap.dedent("""
    【本文】
    {}
    """).format(article_body.strip()) # Use strip() to remove leading/trailing whitespace

    # Add tags
    if tags:
        tags_str = " ".join(tags) # Join tags with space
        note_output += textwrap.dedent(f"""

        ---

        ### タグ
        {tags_str}
        """)

    # Add related link (attempt to get the URL from df_kiji if possible)
    article_link = ""
    if wordpress_url and kadai_id and df_kiji is not None:
        print(f"DEBUG (Note Formatting): Attempting to find WordPress URL for Kadai ID {kadai_id} in df_kiji...")
        # Find the row in df_kiji that matches the kadai_id and has a non-empty '公開URL'
        # Since update_article_history now appends, the latest entry for this kadai_id might be the correct one.
        # Let's find the last row for this kadai_id with a URL.
        # Filter for the specific kadai_id first
        kadai_rows = df_kiji[df_kiji['課題ID'] == kadai_id]

        # Find the latest row (by index, assuming append adds to the end) that has a non-empty '公開URL'
        # Iterate backwards from the latest row for this kadai_id
        latest_url = None
        if not kadai_rows.empty:
             # Sort by index in descending order to get the latest appended rows first
             for index, row in kadai_rows.sort_index(ascending=False).iterrows():
                  url = row.get('公開URL')
                  if pd.notna(url) and url and isinstance(url, str):
                       latest_url = url.strip()
                       print(f"DEBUG (Note Formatting): Found URL in df_kiji for Kadai ID {kadai_id}: {latest_url}")
                       break # Found the latest URL, exit loop

        if latest_url:
            article_link = latest_url
        else:
            print(f"DEBUG (Note Formatting): No URL found in df_kiji for Kadai ID {kadai_id}. Cannot add related link.")


    # If a link was found, add the related link section
    if article_link:
        note_output += textwrap.dedent(f"""

        ---

        ### 関連リンク
        📘 より詳細な記事はこちら：
        👉 {article_link}
        """)

    return note_output.strip()


# --- Example Usage ---
# This example assumes you have:
# - generated_article_body (from the article_writer function call)
# - suggested_tags (list of strings from tag suggestion)
# - selected_kadai_id (from the selection process)
# - df_kiji (the global DataFrame from spreadsheet loading/updating)

# Check if required variables are available from previous steps
if 'generated_article_body' in locals() and 'suggested_tags' in locals() and 'selected_kadai_id' in locals() and 'df_kiji' in globals():
    print("\n--- Note投稿用データ生成 ---")
    # Get WordPress URL from environment variables if available
    wordpress_base_url = os.getenv("WORDPRESS_URL")
    if not wordpress_base_url:
         print("警告: 環境変数 'WORDPRESS_URL' が設定されていません。関連リンクは追加されません。")

    # Call the formatting function
    note_formatted_content = format_for_note(
        article_body=generated_article_body, # Use the generated body
        tags=suggested_tags, # Use the suggested tags
        wordpress_url=wordpress_base_url, # Pass the WP URL
        kadai_id=selected_kadai_id, # Pass the Kadai ID
        df_kiji=df_kiji # Pass the df_kiji DataFrame
    )

    # Display the formatted content in a Textarea for easy copying
    print("\n--- Note投稿用コンテンツ (以下をコピーしてください) ---")
    note_output_textarea = widgets.Textarea(
        value=note_formatted_content,
        description='Noteコンテンツ:',
        disabled=False,
        layout=widgets.Layout(width='95%', height='400px') # Adjust height as needed
    )
    display(note_output_textarea)

    print("\nNote投稿用のコンテンツが生成されました。上記のテキストエリアからコピーしてNoteに貼り付けてください。")

else:
    print("\nNote投稿用データ生成に必要な変数が見つかりません（generated_article_body, suggested_tags, selected_kadai_id, df_kiji）。")
    print("記事本文生成、タグ提案、最終編集・投稿UIのステップが正常に完了しているか確認してください。")

"""# ee103437"""

# Define post_to_x function for X (formerly Twitter) posting
# This function uses the tweepy library to post to X.
# Ensure tweepy is installed (`!pip install tweepy`)

import tweepy
import os
import json
import traceback

def post_to_x(article_url: str = None, message: str = None) -> dict:
    """
    Posts a message to X (formerly Twitter) using the API.

    Args:
        article_url (str, optional): The URL of the article to include in the post. Defaults to None.
        message (str, optional): The main message text for the post. Defaults to None.

    Returns:
        dict: A dictionary containing the status ('success' or 'failure') and a message.
              If successful, includes 'id' and 'text' of the created tweet.
    """
    print("Attempting to post to X...")

    # Get API keys from environment variables
    consumer_key = os.getenv("X_CONSUMER_KEY")
    consumer_secret = os.getenv("X_CONSUMER_SECRET")
    access_token = os.getenv("X_ACCESS_TOKEN")
    access_token_secret = os.getenv("X_ACCESS_TOKEN_SECRET")

    # Check if all credentials are set
    if not all([consumer_key, consumer_secret, access_token, access_token_secret]):
        print("Error: X API credentials are not fully set in environment variables.")
        return {"status": "failure", "message": "X API credentials missing."}

    # Prepare the tweet text
    tweet_text = message
    if article_url:
        # Append the URL. X automatically shortens URLs.
        # Ensure there's a space if message is not empty
        if tweet_text:
            tweet_text = f"{tweet_text} {article_url}"
        else:
            tweet_text = article_url # Just the URL if no message

    if not tweet_text:
        print("Error: No message or URL provided for X post.")
        return {"status": "failure", "message": "No content for X post."}

    print(f"Prepared tweet text: {tweet_text}")

    try:
        # Authenticate with X API (using OAuth 1.0a for posting)
        # The tweepy.Client uses OAuth 2.0 Bearer Token for Read-only,
        # but for posting (write actions), OAuth 1.0a is typically used with Consumer Keys and Access Tokens.
        # Let's use tweepy's API class which supports OAuth 1.0a for posting.

        auth = tweepy.OAuth1UserHandler(
           consumer_key, consumer_secret, access_token, access_token_secret
        )
        api = tweepy.API(auth)

        # Verify credentials (optional but good practice)
        try:
            api.verify_credentials()
            print("X API Authentication successful.")
        except Exception as e:
            print(f"Error verifying X API credentials: {e}")
            return {"status": "failure", "message": f"X API Authentication failed: {e}"}

        # Post the tweet
        # Use the v2 post endpoint if possible with tweepy Client, but v1.1 is simpler for basic text post
        # tweepy.API uses v1.1 by default for update_status
        # Using update_status for simple text post
        # For v2, you'd use tweepy.Client().create_tweet
        # Let's stick to tweepy.API and v1.1 for simplicity if the user's environment supports it.
        # Note: v1.1 endpoints are being deprecated. A v2 implementation using tweepy.Client.create_tweet is more future-proof.
        # Let's provide a v2 implementation using tweepy.Client as it's the current standard.

        # --- Using tweepy Client (v2) ---
        client_v2 = tweepy.Client(
            consumer_key=consumer_key, consumer_secret=consumer_secret,
            access_token=access_token, access_token_secret=access_token_secret
        )
        print("Attempting to post using tweepy.Client (v2)...")
        response = client_v2.create_tweet(text=tweet_text)

        if response and response.data:
            print("X post created successfully (v2).")
            tweet_info = response.data
            return {
                "status": "success",
                "message": "X post created successfully.",
                "id": tweet_info.get('id'),
                "text": tweet_info.get('text')
            }
        else:
             print("Failed to create X post using tweepy.Client (v2). Response data missing.")
             # Fallback to v1.1 if v2 fails or returns unexpected structure
             print("Attempting to post using tweepy.API (v1.1 fallback)...")
             try:
                 # Re-authenticate using v1.1 handler
                 auth_v1 = tweepy.OAuth1UserHandler(
                    consumer_key, consumer_secret, access_token, access_token_secret
                 )
                 api_v1 = tweepy.API(auth_v1)
                 tweet_v1 = api_v1.update_status(tweet_text)
                 print("X post created successfully (v1.1 fallback).")
                 return {
                     "status": "success",
                     "message": "X post created successfully (v1.1 fallback).",
                     "id": tweet_v1.id_str, # v1.1 returns id_str
                     "text": tweet_v1.text
                 }
             except Exception as v1_e:
                  print(f"Failed to create X post using tweepy.API (v1.1 fallback). Error: {v1_e}")
                  # Try to get error details from tweepy exception if possible
                  error_message = f"Failed to create X post. Error: {v1_e}"
                  # Check if the exception has a response attribute (for API errors)
                  if hasattr(v1_e, 'response') and v1_e.response is not None:
                      try:
                          error_json = v1_e.response.json()
                          error_message += f" Details: {error_json}"
                          print(f"API Error Details: {error_json}")
                      except json.JSONDecodeError:
                          pass # Cannot parse JSON from response

                  return {"status": "failure", "message": error_message}


    except Exception as e:
        print(f"An error occurred during X API request: {e}")
        print(traceback.format_exc()) # Print traceback for unexpected errors
        return {
            "status": "failure",
            "message": f"An unexpected error occurred during X API request: {e}"
        }

# The post_to_x function is now defined.
print("\n`post_to_x` 関数が定義されました。")
print("この関数は、設定されたX APIキーを使用して投稿を実行します。")
print("実行には tweepy ライブラリが必要です。インストールされていない場合は `!pip install tweepy` を実行してください。")

"""# 4e9f5803"""

# --- ヘルパー関数の定義 ---
# このセルは、記事候補の整形やテンプレート生成に必要な関数を定義します。
# セル 5b6bdb71 の内容を直接実行するために再生成されています。

import pandas as pd
import re
import datetime

print("--- ヘルパー関数の定義 ---")

def format_kiroku_block(df_kiroku: pd.DataFrame, kadai_id: str) -> str:
    """
    df_kiroku から指定された課題IDに紐づく記録を抽出し、整形して返す関数。
    記録日、記録内容、指導内容、次のアクションをまとめて整形します。
    """
    if df_kiroku.empty or '課題ID' not in df_kiroku.columns:
        # print("警告: df_kirokuが空であるか、'課題ID'カラムがありません。記録整形をスキップします。")
        return f"課題ID '{kadai_id}' に紐づく記録データが見つかりませんでした。"

    # 課題IDでフィルタリング
    kiroku_records = df_kiroku[df_kiroku['課題ID'] == kadai_id].copy()

    if kiroku_records.empty:
        # print(f"警告: 課題ID '{kadai_id}' の記録データが見つかりませんでした。")
        return f"課題ID '{kadai_id}' に紐づく記録データが見つかりませんでした。"

    # 日付でソート (記録日カラムを想定)
    # '記録日'カラムが存在し、日付形式であればソート
    if '記録日' in kiroku_records.columns:
        try:
            # Attempt to convert to datetime, coerce errors to NaT
            kiroku_records['記録日_dt'] = pd.to_datetime(kiroku_records['記録日'], errors='coerce')
            # Sort by the datetime column, putting NaTs last (or skipping them)
            kiroku_records = kiroku_records.sort_values(by='記録日_dt', na_position='last').drop(columns='記録日_dt')
            # Format date back to string or keep as is if original was string
            if pd.api.types.is_datetime64_any_dtype(kiroku_records['記録日'].dtype):
                 kiroku_records['記録日'] = kiroku_records['記録日'].dt.strftime('%Y-%m-%d') # Example format
        except Exception as e:
            print(f"警告: 記録日カラムのソートに失敗しました: {e}")
            # Continue without sorting if date conversion fails


    formatted_blocks = []
    # 必要なカラムをリストアップ
    required_record_cols = ['記録日', '記録内容', '指導内容', '次のアクション']
    # 実際のカラムリスト（存在するものだけ）
    actual_record_cols = [col for col in required_record_cols if col in kiroku_records.columns]

    for index, row in kiroku_records.iterrows():
        block = f"--- 記録日: {row.get('記録日', '日付不明')} ---\n"
        if '記録内容' in actual_record_cols and pd.notna(row['記録内容']):
            block += f"記録内容:\n{row['記録内容'].strip()}\n"
        if '指導内容' in actual_record_cols and pd.notna(row['指導内容']):
             block += f"指導内容:\n{row['指導内容'].strip()}\n"
        if '次のアクション' in actual_record_cols and pd.notna(row['次のアクション']):
             block += f"次のアクション:\n{row['次のアクション'].strip()}\n"

        formatted_blocks.append(block.strip()) # strip each block to remove trailing newlines

    if formatted_blocks:
        return "\n\n".join(formatted_blocks) # Join blocks with double newline
    else:
        return f"課題ID '{kadai_id}' に紐づく記録データは見つかりませんでした。" # Should not happen if kiroku_records is not empty, but for safety


def parse_player_id_with_grade(player_id_str: str) -> tuple[str, str]:
    """
    選手ID文字列からイニシャルと学年をパースする関数。
    例: 'TaroY(中3)' -> ('TY', '中3')
    例: 'JiroS(高1)' -> ('JS', '高1')
    例: 'HanakoA' -> ('HA', '学年不明')
    """
    if not isinstance(player_id_str, str) or not player_id_str.strip():
        return ('ID不明', '学年不明')

    # イニシャルを抽出 (アルファベットの大文字/小文字をまとめて取得)
    initials_match = re.match(r'([A-Za-z]+)([A-Za-z]+)?', player_id_str.strip())
    initials = ''
    if initials_match:
         initials = ''.join([name[0].upper() for name in initials_match.groups() if name])
    if not initials: # Fallback if regex fails or no letters found at start
         initials = ''.join([c.upper() for c in player_id_str if c.isalpha()])
         if len(initials) > 2: initials = initials[:2] # Limit length


    # 学年を抽出 (括弧内の文字列)
    grade_match = re.search(r'\((.+)\)', player_id_str)
    grade = '学年不明'
    if grade_match:
        grade = grade_match.group(1).strip()

    if not initials: initials = 'ID不明' # Ensure initials is not empty if no letters found

    return (initials, grade)

print("ヘルパー関数の定義が完了しました。")

"""# dec2c61f"""

# Google スプレッドシートからデータを再読み込み

import pandas as pd
# gspread と google.colab.auth, google.auth は既に認証・インポート済みを想定

print("--- Google スプレッドシートから DataFrame を再読み込み ---")

try:
    # Declare global variables at the beginning of the block where they are assigned
    global df_kadai, df_kiroku, df_kiji

    # Initialize DataFrames as empty in case sheets are not found
    df_kadai = pd.DataFrame()
    df_kiroku = pd.DataFrame()
    df_kiji = pd.DataFrame()


    # スプレッドシートの名前を指定
    SPREADSHEET_NAME = "指導DB"

    # スプレッドシートを開く
    # gc は認証済みの gspread クライアントを想定
    spreadsheet = gc.open(SPREADSHEET_NAME)
    print(f"スプレッドシート '{SPREADSHEET_NAME}' を開きました。")

    # 各シートを選択して DataFrame に読み込み
    # '課題ID', 'テンプレート', '記事化対象' が含まれるシート
    sheet_name_kadai = "課題"
    if sheet_name_kadai in [ws.title for ws in spreadsheet.worksheets()]:
        ws_kadai = spreadsheet.worksheet(sheet_name_kadai)
        # Assignment after global declaration
        df_kadai = pd.DataFrame(ws_kadai.get_all_records())
        print(f"シート '{sheet_name_kadai}' ({len(df_kadai)}行) を df_kadai に読み込みました。")
        # display(df_kadai.head()) # Optional: Display head to verify columns
    else:
        print(f"警告: シート '{sheet_name_kadai}' が見つかりません。df_kadai は空のDataFrameになります。")


    # 記録データが含まれるシート
    sheet_name_kiroku = "記録"
    if sheet_name_kiroku in [ws.title for ws in spreadsheet.worksheets()]:
        ws_kiroku = spreadsheet.worksheet(sheet_name_kiroku)
        # Assignment after global declaration
        df_kiroku = pd.DataFrame(ws_kiroku.get_all_records())
        print(f"シート '{sheet_name_kiroku}' ({len(df_kiroku)}行) を df_kiroku に読み込みました。")
        # display(df_kiroku.head()) # Optional: Display head to verify columns
    else:
        print(f"警告: シート '{sheet_name_kiroku}' が見つかりません。df_kiroku は空のDataFrameになります。")


    # 記事履歴データが含まれるシート (任意)
    sheet_name_kiji = "記事履歴DB"
    if sheet_name_kiji in [ws.title for ws in spreadsheet.worksheets()]:
         ws_kiji = spreadsheet.worksheet(sheet_name_kiji)
         # Assignment after global declaration
         df_kiji = pd.DataFrame(ws_kiji.get_all_records())
         print(f"シート '{sheet_name_kiji}' ({len(df_kiji)}行) を df_kiji に読み込みました。")
         # display(df_kiji.head()) # Optional: Display head
    else:
         print(f"警告: シート '{sheet_name_kiji}' が見つかりません。df_kiji は空のDataFrameになります。")


    print("\nDataFrame の再読み込みが完了しました。")

except gspread.SpreadsheetNotFound:
    print(f"エラー: 指定されたタイトルのスプレッドシート '{SPREADSHEET_NAME}' が見つかりません。タイトルを確認してください。")
    # DataFrames are already initialized as empty at the beginning of try block
except Exception as e:
    print(f"エラー: スプレッドシートの読み込み中に予期せぬエラーが発生しました: {e}")
    import traceback
    print(traceback.format_exc())
    # DataFrames are already initialized as empty at the beginning of try block

"""# 252f543c"""

# Example code to create 'record_text' column by concatenating existing columns in df_kiroku

import pandas as pd # Make sure pandas is imported

# Assuming df_kiroku has already been loaded from your spreadsheet
# Example: df_kiroku = pd.read_excel('your_record_sheet.xlsx') # Or from Google Sheets API etc.

# --- START: Add this code AFTER df_kiroku is loaded ---

if 'df_kiroku' in globals() and isinstance(globals()['df_kiroku'], pd.DataFrame):
    df_kiroku = globals()['df_kiroku']
    print("DEBUG: df_kiroku DataFrameが見つかりました。'record_text'カラムの生成を試みます。")

    # --- Specify the list of columns to concatenate ---
    # !!! IMPORTANT !!!
    # Replace these placeholder column names with the actual column names
    # from your df_kiroku that contain the record content you want in 'record_text'.
    record_content_columns = ['課題ID', '課題タイトル', '日付', '次回方針', 'テーマ', '記事作成日', '状態', '原因', '働きかけのテーマ', 'やりとり', '選手の反応や悩み', '過去のバイアスや変化を邪魔している生き方や出来事', '使用した比喩や伝え方', '変化', '鍵となった問いかけやバイアス・ブロックの解除', '指導時のチェックポイント', '記事化ステータス', '他の選手や競技へのヒント']

    # Check if all specified columns exist in df_kiroku
    missing_cols = [col for col in record_content_columns if col not in df_kiroku.columns]

    if missing_cols:
        print(f"エラー: 指定された記録内容カラム {missing_cols} が df_kiroku に見つかりません。")
        print("record_content_columns リストが、あなたの記録シートの実際のリカラム名と一致しているか確認してください。")
        # You might want to stop processing or handle this error appropriately
    else:
        # Concatenate the columns into a new 'record_text' column
        # Convert each column to string type and handle potential NaN values by replacing them with empty strings
        # Join the content of each row's specified columns using a separator (e.g., newline and a marker)
        separator = "\n---\n" # Or just "\n" or " "

        # Apply concatenation row by row
        df_kiroku['record_text'] = df_kiroku[record_content_columns].astype(str).agg(separator.join, axis=1)

        # Optional: Clean up potential multiple separators if some original columns were empty
        df_kiroku['record_text'] = df_kiroku['record_text'].str.replace(f'({re.escape(separator)})+', separator, regex=True)
        # Optional: Remove leading/trailing separators
        df_kiroku['record_text'] = df_kiroku['record_text'].str.strip(separator)


        print(f"'record_text' カラムを生成しました。最初の5行のサンプル:\n{df_kiroku['record_text'].head().to_string()}")
        print("\nこれで 'record_text' カラムが利用可能になりました。")

else:
    print("エラー: df_kiroku DataFrame が見つかりませんでした。データ読み込みセルが実行されたか確認してください。")

# --- END: Add this code AFTER df_kiroku is loaded ---

"""# 5b6bdb71"""

# --- ヘルパー関数の定義 ---
# このセルは、記事候補の整形やテンプレート生成に必要な関数を定義します。

import pandas as pd
import re
import datetime
import textwrap # Added import
import os # Added import
from openai import OpenAI # Added import
import traceback # Added import


print("--- ヘルパー関数の定義 ---")

print("--- ヘルパー関数の定義 ---")

def format_kiroku_block(df_kiroku: pd.DataFrame, kadai_id: str) -> str:
    """
    df_kiroku から指定された課題IDに紐づく記録を抽出し、整形して返す関数。
    該当課題IDのすべての記録の、存在する全ての列をまとめて整形します。
    """
    if df_kiroku.empty or '課題ID' not in df_kiroku.columns:
        print("警告: df_kirokuが空であるか、'課題ID'カラムがありません。記録整形をスキップします。")
        return f"課題ID '{kadai_id}' に紐づく記録データが見つかりませんでした。"

    # 課題IDでフィルタリング
    kiroku_records = df_kiroku[df_kiroku['課題ID'] == kadai_id].copy()

    if kiroku_records.empty:
        print(f"警告: 課題ID '{kadai_id}' の記録データが見つかりませんでした。")
        return f"課題ID '{kadai_id}' に紐づく記録データが見つかりませんでした。"

    # 日付でソート ('日付'カラムを想定)
    # MODIFIED: Ensure date column handling is robust.
    date_column = '日付' # Assume '日付' is the date column name
    if date_column in kiroku_records.columns:
        try:
            # Attempt to convert to datetime, coerce errors to NaT
            kiroku_records[f'{date_column}_dt'] = pd.to_datetime(kiroku_records[date_column], errors='coerce')
            # Sort by the datetime column, putting NaTs last
            kiroku_records = kiroku_records.sort_values(by=f'{date_column}_dt', na_position='last')
            # Optional: Format date back to string if needed, or keep as datetime for display
            # Let's keep it as is, display will handle datetime objects nicely
            # Remove the temporary datetime column AFTER sorting is confirmed to work
            if f'{date_column}_dt' in kiroku_records.columns:
                 kiroku_records = kiroku_records.drop(columns=f'{date_column}_dt')

        except Exception as e:
            print(f"警告: 日付カラム ('{date_column}') のソートまたは変換に失敗しました: {e}")
            # Continue without sorting if date conversion fails


    formatted_blocks = []
    # MODIFIED: Iterate through all columns in the filtered DataFrame
    columns_to_format = kiroku_records.columns.tolist()
    # Optionally, move '課題ID' to the end or exclude it if desired, but including all is safer initially.
    # Let's exclude '課題ID' as it's the filter criterion and might be redundant in each block.
    if '課題ID' in columns_to_format:
        columns_to_format.remove('課題ID')
    # Also exclude the '紐付け課題（リレーション）' column if it exists, as it might be redundant.
    if '紐付け課題（リレーション）' in columns_to_format:
         columns_to_format.remove('紐付け課題（リレーション）')


    # DEBUG: Print the columns being used for formatting
    print(f"DEBUG (format_kiroku_block): Using columns for formatting: {columns_to_format}")
    # DEBUG: Print the records found for the Kadai ID before formatting
    print(f"DEBUG (format_kiroku_block): Records found for Kadai ID '{kadai_id}':")
    # Display only the columns that will be used, if they exist
    if columns_to_format:
         display(kiroku_records[columns_to_format])
    else:
         # Fallback to displaying all columns if none of the intended columns are found
         display(kiroku_records)


    for index, row in kiroku_records.iterrows():
        # Start each block, optionally using the date column if it exists
        block_header = f"--- 記録 ({index}) ---" # Use row index for simple identification
        if date_column in row and pd.notna(row[date_column]):
            # Format date nicely if it's a datetime object
            if isinstance(row[date_column], pd.Timestamp):
                date_str = row[date_column].strftime('%Y-%m-%d') # Example format
            else:
                date_str = str(row[date_column])
            block_header = f"--- 記録 ({index}) - 日付: {date_str} ---"

        block = block_header + "\n"

        # Add content for all selected columns
        for col in columns_to_format:
             # Check if the column exists in the row and the value is not NaN/None and is not just whitespace
             # Use .get() with a default to avoid KeyError if column somehow missing in a specific row (unlikely)
             value = row.get(col)
             if pd.notna(value) and str(value).strip() != '':
                 # Add the column name and the content
                 # Ensure value is converted to string for display
                 block += f"{col}:\n{str(value).strip()}\n"


        formatted_blocks.append(block.strip()) # strip each block to remove trailing newlines

    if formatted_blocks:
        # DEBUG: Print a sample of the first formatted block
        print(f"DEBUG (format_kiroku_block): Sample of first formatted block:\n{formatted_blocks[0][:500]}...")
        return "\n\n".join(formatted_blocks) # Join blocks with double newline
    else:
        # This case should ideally be covered by the initial empty check, but for safety
        print(f"DEBUG (format_kiroku_block): No formatted blocks generated for Kadai ID '{kadai_id}'.")
        return f"課題ID '{kadai_id}' に紐づく記録データが見つかりませんでした。"


def parse_player_id_with_grade(player_id_str: str) -> tuple[str, str]:
    """
    選手ID文字列からイニシャルと学年をパースする関数。
    例: 'TaroY(中3)' -> ('TY', '中3')
    例: 'JiroS(高1)' -> ('JS', '高1')
    例: 'HanakoA' -> ('HA', '学年不明')
    """
    if not isinstance(player_id_str, str) or not player_id_str.strip():
        return ('ID不明', '学年不明')

    # Remove content within parentheses first to simplify initial extraction
    cleaned_id_str = re.sub(r'\(.*?\)', '', player_id_str).strip()

    # Extract initials (first letter of each word/part before numbers/symbols)
    # Use findall to get sequences of letters
    initial_parts = re.findall(r'[A-Za-z]+', cleaned_id_str)
    initials = ''.join([part[0].upper() for part in initial_parts if part])

    # Fallback if no initials found (e.g., ID is purely numeric or symbols)
    if not initials:
         # Take first few non-space characters and capitalize, up to 2-3 chars
         initials = ''.join([c for c in cleaned_id_str if c.isalnum()])[:3].upper()
         if not initials: initials = 'ID不明' # Final fallback


    # 学年を抽出 (括弧内の文字列)
    grade_match = re.search(r'\((.+)\)', player_id_str)
    grade = '学年不明'
    if grade_match:
        grade = grade_match.group(1).strip()

    if not initials: initials = 'ID不明' # Ensure initials is not empty if no letters found


    return (initials, grade)

# --- Helper function to call DALL-E image generation ---
# Added based on user provided code and previous error
def generate_image_with_dalle(prompt: str) -> dict:
    """
    Helper function to call DALL-E image generation using OpenAI API.

    Args:
        prompt (str): The prompt for image generation.

    Returns:
        dict: A dictionary containing the status ('success' or 'failure'),
              a message, and the image URL if successful.
    """
    print(f"DEBUG (generate_image_with_dalle): Attempting to generate image for prompt: {prompt[:100]}...")
    try:
        # Ensure OpenAI client is initialized
        api_key = os.getenv("OPENAI_API_KEY")
        if not api_key:
            return {"status": "failure", "message": "環境変数 'OPENAI_API_KEY' が設定されていません。"}

        client = OpenAI(api_key=api_key)

        # Use DALL-E 3 as requested by the user, n is always 1
        image_response = client.images.generate(
            model="dall-e-3", # Specify DALL-E 3
            prompt=prompt,
            n=1, # DALL-E 3 always generates 1 image per call
            size="1024x1024", # Using a larger size recommended for DALL-E 3
            quality="standard" # Add quality parameter (standard or hd)
        )

        if image_response.data and image_response.data[0].url:
            image_url = image_response.data[0].url
            # DALL-E 3 might return revised prompts in revised_prompt
            # print(f"DEBUG (generate_image_with_dalle): DALL-E 3 Revised Prompt: {image_response.data[0].revised_prompt}")
            print(f"DEBUG (generate_image_with_dalle): Image generated successfully. URL: {image_url[:50]}...")
            return {"status": "success", "message": "画像生成成功", "url": image_url}
        else:
            message = "警告: DALL-E APIからの応答に有効な画像URLがありませんでした。"
            print(f"DEBUG (generate_image_with_dalle): {message} (プロンプト: {prompt[:100]}...)")
            return {"status": "failure", "message": message}

    except Exception as img_e:
        message = f"エラー: DALL-E API呼び出し中に予期せぬエラーが発生しました: {img_e}"
        print(f"DEBUG (generate_image_with_dalle): {message} (プロンプト: {prompt[:100]}...)")
        print(traceback.format_exc())
        return {"status": "failure", "message": message}


print("ヘルパー関数の定義が完了しました。")

"""# 18"""

# Helper functions for updating Google Sheets

import pandas as pd
from google.colab import auth
from googleapiclient.discovery import build
from google.auth import default
import gspread
from gspread_dataframe import set_with_dataframe
import time
import traceback
# MODIFIED: Explicitly import datetime class from datetime module
from datetime import datetime

# Authenticate and create the gspread client
# This part assumes authentication has already been done in a previous cell
# try:
#     auth.authenticate_user()
#     creds, project = default()
#     gc = gspread.authorize(creds)
#     print("DEBUG: Google Colab authentication successful.")
# except Exception as e:
#     print(f"ERROR: Google Colab authentication failed: {e}")
#     gc = None # Set gc to None if authentication fails

# Assuming 'gc' (gspread client) is available from previous authentication cell
if 'gc' not in globals() or globals()['gc'] is None:
     print("警告: gspread クライアント (gc) が利用できません。Google Sheetsへの書き込みはスキップされます。認証セルを実行してください。")
     gc = None # Ensure gc is None if not globally available


# Function to update the '記事履歴DB' sheet
def update_article_history(publishing_results: list, df_kiji: pd.DataFrame):
    """
    Updates the '記事履歴DB' Google Sheet DataFrame (df_kiji) with new article data.

    Args:
        publishing_results (list): A list of dictionaries, where each dict
                                   contains publishing results for one article.
                                   Expected keys: 'kadai_id', 'article_title',
                                   'wordpress_url', 'wordpress_post_id', 'wp_status',
                                   'selected_record_index', 'tags', 'featured_image_url',
                                   'featured_image_id', 'selected_category_slug'.
        df_kiji (pd.DataFrame): The current DataFrame representing the '記事履歴DB' sheet.

    Returns:
        pd.DataFrame: The updated df_kiji DataFrame. Returns the original df_kiji
                      if updates cannot be made (e.g., gc not available).
    """
    print("\n--- 記事履歴DBを更新中 ---")
    if gc is None:
        print("エラー: gspread クライアントが利用できないため、記事履歴DBの更新をスキップします。")
        return df_kiji # Return original DataFrame if cannot update

    if not publishing_results:
        print("警告: 更新対象の投稿結果データがありません。記事履歴DBの更新をスキップします。")
        return df_kiji

    updated_rows = []

    for result in publishing_results:
        wp_status = result.get('wp_status')
        wordpress_url = result.get('wordpress_url')
        wordpress_post_id = result.get('wordpress_post_id')
        kadai_id = result.get('kadai_id')
        article_title = result.get('article_title')
        selected_record_index = result.get('selected_record_index') # Get the record index
        tags = result.get('tags', []) # Get tags as a list
        featured_image_url = result.get('featured_image_url')
        featured_image_id = result.get('featured_image_id')
        selected_category_slug = result.get('selected_category_slug')


        # Construct the row data for df_kiji
        # Ensure data types match expected sheet columns
        # MODIFIED: Use datetime.now() assuming from datetime import datetime
        public_date = datetime.now().strftime('%Y-%m-%d %H:%M:%S') if wp_status == "success" else ''
        wp_post_id_str = str(wordpress_post_id) if wordpress_post_id else '' # Convert ID to string
        tags_str = ', '.join(tags) if tags else '' # Join tags into a comma-separated string
        featured_image_id_str = str(featured_image_id) if featured_image_id else '' # Convert ID to string


        # Create a dictionary representing the new row based on sheet columns
        # Ensure column names match your '記事履歴DB' sheet exactly.
        # Assuming column names like: '課題ID', '記事タイトル', 'WordPress URL',
        # 'WordPress投稿ID', '投稿日時', '元記録インデックス', 'タグ', 'アイキャッチ画像URL',
        # 'アイキャッチ画像ID', 'カテゴリー'.
        # You might need to adjust these column names based on your actual sheet.
        new_row_data = {
            '課題ID': kadai_id,
            '記事タイトル': article_title,
            'WordPress URL': wordpress_url if wordpress_url else '',
            'WordPress投稿ID': wp_post_id_str,
            '投稿日時': public_date, # Use the formatted current date/time or empty
            '元記録インデックス': selected_record_index, # Store the original record index
            'タグ': tags_str, # Store tags as a string
            'アイキャッチ画像URL': featured_image_url if featured_image_url else '',
            'アイキャッチ画像ID': featured_image_id_str,
            'カテゴリー': selected_category_slug if selected_category_slug else '',
            # Add other columns from your sheet if necessary, providing default empty values
            # 'ステータス': '投稿済み' if wp_status == 'success' else f'投稿失敗 ({wp_status})', # Example status column
        }
        # Ensure all expected columns are present in new_row_data, even if not explicitly set above
        # This prevents errors if set_with_dataframe expects a certain column structure
        # This step requires knowing all column names in df_kiji beforehand.
        # A safer approach is to ensure the sheet has the expected columns and handle missing keys above.
        # For now, assume new_row_data contains the necessary keys that match df_kiji columns.

        updated_rows.append(new_row_data)


    if not updated_rows:
        print("警告: 有効な更新対象データが生成されませんでした。記事履歴DBの更新をスキップします。")
        return df_kiji

    # Convert updated_rows to a DataFrame
    new_articles_df = pd.DataFrame(updated_rows)

    # Append new data to the existing df_kiji DataFrame
    # Use pandas.concat to append, ignoring index
    # MODIFIED: Ensure column order matches df_kiji before concatenating
    # This is important for set_with_dataframe to write to the correct columns.
    # Get the column order from the original df_kiji
    if not df_kiji.empty:
        kiji_column_order = df_kiji.columns.tolist()
        # Reindex the new_articles_df to match the column order of df_kiji
        # Columns in new_articles_df that are not in df_kiji will be added at the end (or dropped if desired)
        # Columns in df_kiji that are not in new_articles_df will have NaN values for the new rows
        new_articles_df = new_articles_df.reindex(columns=kiji_column_order, fill_value='') # Fill missing columns in new data with empty string

    # Check for columns in new_articles_df that are NOT in df_kiji (original sheet columns)
    extra_cols = [col for col in new_articles_df.columns if col not in df_kiji.columns]
    if extra_cols:
         print(f"警告: 更新データに、記事履歴DBシートに存在しないカラムが見つかりました: {extra_cols}. これらのカラムはシートに書き込まれません。")
         # Optionally drop these columns from new_articles_df before concatenating
         # new_articles_df = new_articles_df.drop(columns=extra_cols)

    # Check for columns in df_kiji that are NOT in new_articles_df (data being appended)
    missing_cols_in_new_data = [col for col in df_kiji.columns if col not in new_articles_df.columns]
    if missing_cols_in_new_data:
         print(f"警告: 記事履歴DBシートには存在するが、更新データに含まれていないカラムがあります: {missing_cols_in_new_data}. これらのカラムは新しい行で空になります。")
         # Ensure these columns are added to new_articles_df with fill_value (done by reindex above)


    # Concatenate the original df_kiji and the new articles DataFrame
    # Use ignore_index=True to reset the index of the combined DataFrame
    updated_df_kiji = pd.concat([df_kiji, new_articles_df], ignore_index=True)

    print(f"DEBUG: Updated df_kiji shape after concatenation: {updated_df_kiji.shape}")

    # Write the updated DataFrame back to the '記事履歴DB' sheet
    try:
        # Assuming the sheet name is '記事履歴DB' and it's in the same spreadsheet as df_kiroku/df_kadai
        # You might need to get the spreadsheet by name if not already globally available
        spreadsheet_name = '指導DB' # Assuming the spreadsheet name
        try:
            sh = gc.open(spreadsheet_name)
            worksheet = sh.worksheet('記事履歴DB') # Assuming the worksheet name
        except gspread.SpreadsheetNotFound:
            print(f"エラー: スプレッドシート '{spreadsheet_name}' が見つかりません。記事履歴DBの更新をスキップします。")
            return df_kiji
        except gspread.WorksheetNotFound:
             print(f"エラー: スプレッドシート '{spreadsheet_name}' 内にシート '記事履歴DB' が見つかりません。記事履歴DBの更新をスキップします。")
             return df_kiji

        # Use set_with_dataframe to write the DataFrame to the worksheet
        # include_index=False means the pandas index is not written to the sheet
        set_with_dataframe(worksheet, updated_df_kiji, include_index=False)

        print("記事履歴DBシートを更新しました。")
        return updated_df_kiji # Return the updated DataFrame

    except Exception as e:
        print(f"エラー: 記事履歴DBシートへの書き込み中にエラーが発生しました: {e}")
        print(traceback.format_exc())
        return df_kiji # Return original or partially updated DataFrame on error


# Function to update the '記事作成日' column in df_kiroku sheet
def update_kiroku_article_date(record_index: int, publish_date_str: str, df_kiroku: pd.DataFrame):
    """
    Updates the '記事作成日' column for a specific record in the df_kiroku sheet.

    Args:
        record_index (int): The index of the record in the original df_kiroku DataFrame.
        publish_date_str (str): The formatted date string to write to '記事作成日'.
                                Should be '' if publishing failed.
        df_kiroku (pd.DataFrame): The current DataFrame representing the '記録' sheet.

    Returns:
        pd.DataFrame: The updated df_kiroku DataFrame. Returns the original df_kiroku
                      if updates cannot be made (e.g., gc not available, index not found).
    """
    print(f"\n--- 記録シート ('記事作成日') を更新中 (インデックス: {record_index}) ---")
    if gc is None:
        print("エラー: gspread クライアントが利用できないため、記録シートの更新をスキップします。")
        return df_kiroku

    # Check if the record_index exists in the DataFrame's index
    if record_index not in df_kiroku.index:
        print(f"エラー: 指定された記録インデックス ({record_index}) が df_kiroku に見つかりません。記録シートの更新をスキップします。")
        return df_kiroku

    # Check if '記事作成日' column exists in df_kiroku
    if '記事作成日' not in df_kiroku.columns:
        print("エラー: '記事作成日' カラムが df_kiroku に見つかりません。記録シートの更新をスキップします。")
        return df_kiroku

    # Update the DataFrame in memory
    # Use .loc for label-based indexing to ensure the correct row is updated
    df_kiroku.loc[record_index, '記事作成日'] = publish_date_str
    print(f"DEBUG: df_kiroku (インデックス: {record_index}) の '記事作成日' を '{publish_date_str}' に更新しました (メモリ上)。")

    # Find the row number in the Google Sheet corresponding to the index
    # This requires knowing the mapping between DataFrame index and sheet row number.
    # If the DataFrame was loaded with header=True and no rows were deleted/added in Google Sheets manually
    # after loading, the DataFrame index + 2 corresponds to the sheet row number (1-based index + header row).
    # Assuming the header is in row 1 of the sheet.
    sheet_row_number = record_index + 2 # Adjust based on your sheet's header row and 1-based indexing

    print(f"DEBUG: 記録シートの更新対象行番号 (Google Sheets): {sheet_row_number}")

    # Write the updated DataFrame back to the '記録' sheet
    # Alternatively, update only the specific cell in the sheet for efficiency.
    # Updating a single cell is more efficient than writing the whole DataFrame.

    # Find the column index for '記事作成日' in the Google Sheet
    try:
        spreadsheet_name = '指導DB' # Assuming the spreadsheet name
        try:
            sh = gc.open(spreadsheet_name)
            worksheet = sh.worksheet('記録') # Assuming the worksheet name
        except gspread.SpreadsheetNotFound:
            print(f"エラー: スプレッドシート '{spreadsheet_name}' が見つかりません。記録シートの更新をスキップします。")
            return df_kiroku
        except gspread.WorksheetNotFound:
             print(f"エラー: スプレッドシート '{spreadsheet_name}' 内にシート '記録' が見つかりません。記録シートの更新をスキップします。")
             return df_kiroku

        # Get all column headers to find the column index
        headers = worksheet.row_values(1) # Assuming header is in row 1
        try:
            # Find the 0-based index of the '記事作成日' column, then add 1 for gspread's 1-based indexing
            article_date_col_index = headers.index('記事作成日') + 1
            print(f"DEBUG: '記事作成日' カラムのシート列番号 (Google Sheets): {article_date_col_index}")
        except ValueError:
            print("エラー: 記録シートのヘッダーに '記事作成日' カラムが見つかりません。記録シートの更新をスキップします。")
            return df_kiroku

        # Update the specific cell
        try:
            worksheet.update_cell(sheet_row_number, article_date_col_index, publish_date_str)
            print(f"記録シート (行 {sheet_row_number}) の '記事作成日' を更新しました。")
            return df_kiroku # Return the updated DataFrame (in memory)
        except Exception as e:
             print(f"エラー: 記録シートの特定セル ({sheet_row_number}, {article_date_col_index}) への書き込み中にエラーが発生しました: {e}")
             print(traceback.format_exc())
             return df_kiroku # Return DataFrame on error


    except Exception as e:
        print(f"エラー: 記録シート ('記事作成日') の更新中に予期せぬエラーが発生しました: {e}")
        print(traceback.format_exc())
        return df_kiroku


# Function to handle X (formerly Twitter) posting
# This function is a placeholder and needs implementation
def post_to_x(article_title: str, article_url: str):
    """
    Posts a link to the new article on X.

    Args:
        article_title (str): The title of the published article.
        article_url (str): The URL of the published article.

    Returns:
        dict: A dictionary with the result of the X post attempt.
              Expected keys: 'status' ('success' or 'failed'), 'message' (optional).
    """
    print("\n--- X (旧Twitter) に投稿中 ---")
    # This is a placeholder. Actual implementation requires X API keys and logic.
    # You need to set up X API credentials securely (e.g., in Colab Secrets).
    # Example using tweepy or other X API libraries:
    # import tweepy
    # consumer_key = os.getenv("X_CONSUMER_KEY")
    # consumer_secret = os.getenv("X_CONSUMER_SECRET")
    # access_token = os.getenv("X_ACCESS_TOKEN")
    # access_token_secret = os.getenv("X_ACCESS_TOKEN_SECRET")
    #
    # if not all([consumer_key, consumer_secret, access_token, access_token_secret]):
    #     print("エラー: X APIの認証情報が設定されていません。Xへの投稿をスキップします。")
    #     return {"status": "failed", "message": "X API credentials missing."}
    #
    # try:
    #     auth = tweepy.OAuthHandler(consumer_key, consumer_secret)
    #     auth.set_access_token(access_token, access_token_secret)
    #     api = tweepy.API(auth)
    #
    #     tweet_text = f"{article_title}\n{article_url}"
    #     print(f"DEBUG: Posting to X: '{tweet_text[:100]}...'")
    #     api.update_status(tweet_text)
    #     print("Xへの投稿が完了しました。")
    #     return {"status": "success", "message": "Posted to X successfully."}
    # except Exception as e:
    #     print(f"エラー: Xへの投稿中にエラーが発生しました: {e}")
    #     print(traceback.format_exc())
    #     return {"status": "failed", "message": f"X post failed: {e}"}

    # Placeholder implementation:
    print("警告: X投稿機能は現在プレースホルダーです。実際の投稿は行われません。")
    print(f"DEBUG: 投稿予定のタイトル: '{article_title}'")
    print(f"DEBUG: 投稿予定のURL: {article_url}")
    return {"status": "skipped", "message": "X posting is a placeholder."}


print("Helper functions for Google Sheets and X posting defined.")

"""# 記事候補生成①　dbfc915c"""

# 記事候補抽出と準備

import pandas as pd
import random # Ensure random is imported for sampling
import json # Ensure json is imported
import os # Ensure os is imported
import textwrap # Ensure textwrap is imported for prompts
import time # Ensure time is imported for API waiting
from openai import OpenAI # Ensure OpenAI is imported
import traceback # Ensure traceback is imported for error reporting

print("--- 記事候補抽出と準備 ---")

# Define the temporary file path for selected candidate data
TEMP_SELECTED_DATA_PATH = '/tmp/selected_candidate_data.json' # Define the temporary file path

# Check if df_kiroku is available
required_dfs = ['df_kiroku']
data_available = True
for df_name in required_dfs:
    if df_name not in globals() or not isinstance(globals()[df_name], pd.DataFrame):
        print(f"エラー: 必要なデータ ({df_name}) が読み込まれていないか、DataFrameではありません。")
        data_available = False

if not data_available:
    print("必要なデータが不足しているため、記事候補の準備をスキップします。")
    print("以下のセルが正常に実行されているか確認してください:")
    print(" - スプレッドシートからのデータ読み込み (dec2c61f)") # Assuming dec2c61f loads df_kiroku
    # Initialize an empty DataFrame to avoid errors in subsequent cells
    article_candidates_df = pd.DataFrame()
else:
    df_kiroku = globals()['df_kiroku']

    # Ensure essential columns exist.
    missing_essential_cols = [col for col in ['record_text', '課題タイトル', '課題ID', '日付'] if col not in df_kiroku.columns]
    if missing_essential_cols:
         print(f"エラー: df_kiroku に必須カラム {missing_essential_cols} が見つかりません。")
         print("記録シートのデータ読み込み・準備のセル (dec2c61f など) で、必要なカラムが読み込まれているか確認してください。")
         article_candidates_df = pd.DataFrame() # Ensure empty DataFrame and stop processing
    else:
        # Ensure '記事作成日' column exists, add if missing (still needed for filtering)
        if '記事作成日' not in df_kiroku.columns:
             df_kiroku['記事作成日'] = '' # Add column as empty string if missing
             print("警告: '記事作成日' カラムが df_kiroku に見つかりませんでした。新規に追加しました。初期値は空文字列です。")


        # --- Step 1: Filter df_kiroku for '記事作成日' is empty/null ---
        print("DEBUG: Filtering df_kiroku based on '記事作成日' being empty...")

        filtered_kiroku_candidates_df = df_kiroku[
            pd.isna(df_kiroku['記事作成日']) | (df_kiroku['記事作成日'].astype(str).str.strip() == '')
        ].copy() # Use .copy()

        print(f"DEBUG: Potential candidates from df_kiroku after filtering by '記事作成日' empty: {len(filtered_kiroku_candidates_df)} rows.")

        if filtered_kiroku_candidates_df.empty:
            print("「記事作成日」が空欄の記録データが見つかりませんでした。記事候補はありません。")
            article_candidates_df = pd.DataFrame() # Ensure an empty DataFrame is created
        else:
            # --- Step 2: Randomly Sample Candidates ---
            # MODIFIED: Select a random sample of candidates from the filtered set.
            num_candidates_to_sample = 3
            num_available_candidates = len(filtered_kiroku_candidates_df)

            if num_available_candidates == 0:
                print("警告: 「記事作成日」が空欄の記録データが見つかりませんでした。ランダムサンプリングをスキップします。")
                sampled_candidates_df = pd.DataFrame() # Empty DataFrame
            elif num_available_candidates <= num_candidates_to_sample:
                print(f"DEBUG: Available candidates ({num_available_candidates}) <= requested sample size ({num_candidates_to_sample}). Using all available candidates.")
                sampled_candidates_df = filtered_kiroku_candidates_df.copy() # Use all if fewer than requested
            else:
                print(f"DEBUG: Randomly sampling {num_candidates_to_sample} candidates from {num_available_candidates} available.")
                # Use .sample() to get a random sample
                sampled_candidates_df = filtered_kiroku_candidates_df.sample(n=num_candidates_to_sample, random_state=42).copy() # Use a fixed random_state for reproducibility if desired, or remove it for true randomness


            if sampled_candidates_df.empty:
                 print("警告: ランダムサンプリングの結果、有効な候補が選択されませんでした。")
                 article_candidates_df = pd.DataFrame() # Ensure empty DataFrame
            else:
                # --- Step 3: Process each SAMPLED record to GENERATE Template Text ---
                # MODIFIED: Iterate through SAMPLED candidates and ALWAYS generate template text inline.
                print(f"DEBUG: Generating template text for {len(sampled_candidates_df)} sampled records...")

                processed_candidates_list = [] # List to store processed rows

                # Initialize OpenAI client for template generation
                openai_client = None
                api_key = os.getenv("OPENAI_API_KEY")
                assistant_id = os.getenv("TEMPLATE_ASSISTANT_ID") # Assuming a dedicated template assistant ID

                if not api_key:
                     print("警告: 環境変数 'OPENAI_API_KEY' が設定されていません。テンプレート生成をスキップします。")
                     openai_client_available = False
                     openai_error_msg = "OpenAI APIキーが設定されていません。"
                elif not assistant_id:
                     print("警告: 環境変数 'TEMPLATE_ASSISTANT_ID' が設定されていません。テンプレート生成AssistantのIDが必要です。テンプレート生成をスキップします。")
                     openai_client_available = False
                     openai_error_msg = "テンプレート生成Assistant IDが設定されていません。"
                else:
                    try:
                        openai_client = OpenAI(api_key=api_key)
                        openai_client_available = True
                        print("DEBUG: OpenAI client initialized for inline template generation.")
                    except Exception as e:
                        print(f"エラー: OpenAIクライアントの初期化に失敗しました: {e}。テンプレート生成をスキップします。")
                        openai_client_available = False
                        openai_error_msg = f"OpenAIクライアント初期化エラー: {e}"


                # Iterate through the ROWS OF THE SAMPLED DATAFRAME
                for index, row in sampled_candidates_df.iterrows():
                    # MODIFIED: ALWAYS attempt to generate template if OpenAI client is available
                    if openai_client_available:
                        print(f"DEBUG: Attempting to generate template for index {index} (課題ID: {row.get('課題ID')}).")
                        kadai_title = row.get('課題タイトル', 'N/A')
                        record_text = row.get('record_text', '')

                        if not record_text or record_text.strip() == '':
                             print(f"警告: index {index} (課題ID: {row.get('課題ID')}) の record_text が空のため、テンプレート生成をスキップします。")
                             row['template_text'] = "エラー: record_text が空のためテンプレート生成スキップ" # Add a placeholder
                             # No generation needed, proceed to add row
                        else:
                            # --- Inline Template Generation Logic ---
                            template_gen_prompt = textwrap.dedent(f"""
あなたはスポーツ指導記録を元に、読者にとって有益な記事の構成案（テンプレート）を生成するAIアシスタントです。
以下の【課題タイトル】と【指導記録】を元に、WordPressブログ記事の構成案を生成してください。

【構成案に含める要素】
- **ターゲット読者**: 指導者向け、保護者向け、選手向け、または複数対象かを明記
- **仮タイトル**: 読者の興味を引く魅力的なタイトル案
- **切り口**: 記録のどの側面に焦点を当てるか（例: 選手の内面の変化、特定の技術習得プロセス、指導者の工夫）
- **構成案**: 記事本文の具体的なセクション分け（見出し案）と、それぞれのセクションでどのような内容（記録のどの部分を引用・解説するかなど）を記述するかを箇条書きで提案
- **本文作成のポイント**: 記事執筆時に意識すべき点（例: 共感を呼ぶストーリーテリング、専門用語の解説、読者への問いかけ）
- **カテゴリ（主）**: 記事の主要カテゴリ（例: チームと場のデザイン, フォーム改善・身体操作, メンタルと自己認識, 判断・選択・状況理解, 問いと気づきの技術, 実践レポート・対話の記録, 成長の理論と実践, 継続と習慣づくり, 親と子・保護者の関わり, 試合対応力・緊張対策）から最も適切なものを1つ
- **カテゴリ（副）**: 該当する場合、副カテゴリを1つ

【重要】
- 必ず上記の【構成案に含める要素】を全て含めてください。
- Markdown形式で見やすく記述してください。特に構成案は箇条書きを活用してください。
- 指導記録の内容を深く理解し、記録から得られる学びや示唆が読者に伝わるような構成を提案してください。
- 読者タイプに合わせた言葉遣いや視点を意識してください。
- 回答は構成案のみとし、それ以外の前置きや説明は含めないでください。

【課題タイトル】:
{kadai_title}

【指導記録】:
{record_text}

---
構成案を生成してください。
""").strip()

                            try:
                                print(f"--- テンプレート自動生成開始 (index: {index}, 課題ID: {row.get('課題ID')}) ---")
                                thread = openai_client.beta.threads.create()
                                openai_client.beta.threads.messages.create(thread_id=thread.id, role="user", content=template_gen_prompt)
                                run = openai_client.beta.threads.runs.create(thread_id=thread.id, assistant_id=assistant_id)

                                # Wait for the run to complete
                                status = None
                                while True:
                                    status = openai_client.beta.threads.runs.retrieve(thread_id=thread.id, run_id=run.id)
                                    # print(f"DEBUG (Inline Gen): Assistant status: {status.status}") # Avoid excessive printing
                                    if status.status in ["completed", "failed", "cancelled", "expired"]:
                                        print(f"DEBUG (Inline Gen): Assistant run completed with status: {status.status}")
                                        break
                                    if status.status == "requires_action":
                                         print("DEBUG (Inline Gen): Function calling is required, but not implemented in this flow.")
                                         status.status = "failed" # Treat as failure if function calling is needed
                                         break
                                    time.sleep(2) # Wait before polling again

                                generated_template = ""
                                if status and status.status == "completed":
                                    messages = openai_client.beta.threads.messages.list(thread_id=thread.id)
                                    if messages.data:
                                         # Find the last message from the assistant (assuming it contains the template)
                                         assistant_messages = [msg for msg in messages.data if msg.role == 'assistant']
                                         if assistant_messages:
                                              if assistant_messages[0].content:
                                                  for content_block in assistant_messages[0].content:
                                                      if content_block.type == 'text':
                                                           generated_template += content_block.text.value + "\n"
                                              generated_template = generated_template.strip()
                                              print(f"DEBUG (Inline Gen): Extracted generated template length: {len(generated_template)}")
                                         else:
                                              print("警告 (Inline Gen): Assistantからの応答にAssistantのメッセージが見つかりませんでした。")
                                else:
                                     print("警告 (Inline Gen): Assistantからの応答がありませんでした、またはテキストコンテンツがありませんでした。")


                                if generated_template:
                                    row['template_text'] = generated_template # Add generated template to the row data
                                    print(f"--- テンプレート自動生成完了 (index: {index}, 課題ID: {row.get('課題ID')}) ---")
                                else:
                                    print(f"警告: index {index} (課題ID: {row.get('課題ID')}) のテンプレート生成に失敗しました。")
                                    if status and status.last_error:
                                        print(f"エラー詳細 (Assistant): {status.last_error}")
                                    row['template_text'] = f"エラー: テンプレート生成失敗。詳細: {status.last_error.message if status and status.last_error else 'Unknown API error'}" # Add error placeholder

                            except Exception as api_e:
                                print(f"エラー: index {index} (課題ID: {row.get('課題ID')}) のテンプレート生成API呼び出し中に予期せぬエラーが発生しました: {api_e}")
                                print(traceback.format_exc())
                                row['template_text'] = f"エラー: テンプレート生成中に例外発生: {api_e}" # Add error placeholder

                            # --- End Inline Template Generation Logic ---
                        processed_candidates_list.append(row) # Add the processed row to the list (whether generation succeeded or failed)

                    else: # Skip generation if OpenAI client is not available
                        print(f"警告: index {index} (課題ID: {row.get('課題ID')}) のテンプレート生成は、OpenAIクライアントが利用できないためスキップします。")
                        row['template_text'] = "警告: テンプレート生成スキップ（OpenAI利用不可）" # Add a placeholder
                        processed_candidates_list.append(row) # Add the processed row to the list


                # Convert the list of processed rows back into a DataFrame
                # Ensure original index is preserved by setting it during DataFrame creation
                if processed_candidates_list:
                    # Create DataFrame from list of Series (rows)
                    article_candidates_df = pd.DataFrame(processed_candidates_list)
                    # The index should be preserved because we iterated through sampled_candidates_df.iterrows()
                    # and appended the row (which is a Series with the original index).
                    print("DEBUG: Processed candidates list converted back to DataFrame.")

                    # Filter out rows where template generation resulted in an error/skip placeholder
                    # We only want to present candidates for which we have a usable template.
                    error_placeholders = [
                        "エラー: OpenAI APIキーが設定されていません。",
                        "エラー: テンプレート生成Assistant IDが設定されていません。",
                        "エラー: OpenAIクライアント初期化エラー:", # Match this pattern
                        "エラー: record_text が空のためテンプレート生成スキップ",
                        "エラー: テンプレート生成失敗。詳細:", # Match this pattern
                        "エラー: テンプレート生成中に例外発生:", # Match this pattern
                        "警告: テンプレート生成スキップ（OpenAI利用不可）"
                    ]
                    # Filter out rows where 'template_text' starts with any of the error placeholders
                    usable_candidates_df = article_candidates_df[
                        ~article_candidates_df['template_text'].astype(str).str.startswith(tuple(error_placeholders), na=False)
                    ].copy() # Filter out rows with error/skip messages in template_text

                    # Update article_candidates_df to only include usable candidates
                    article_candidates_df = usable_candidates_df
                    print(f"DEBUG: Filtered out candidates with template generation errors/skips. Remaining: {len(article_candidates_df)} rows.")


                    print(f"--- 記事候補として {len(article_candidates_df)} 件を選出しました (テンプレート生成成功分) ---")
                    # Ensure required columns for the next UI step are present
                    # The filtering process keeps original columns. 'template_text' is added.
                    # We need '課題ID', '日付', 'record_text', 'template_text', '課題タイトル' for the UI and next steps.
                    essential_cols_final = ['課題ID', '日付', 'record_text', 'template_text', '課題タイトル'] # Include all necessary cols
                    # Check if these columns are in the final article_candidates_df
                    if not all(col in article_candidates_df.columns for col in essential_cols_final):
                         missing_cols = [col for col in essential_cols_final if col not in article_candidates_df.columns]
                         print(f"エラー: 最終候補DataFrameに必須カラム {missing_cols} が見つかりません。処理を確認してください。")
                         article_candidates_df = pd.DataFrame() # Clear candidates if essential data is missing
                     # else:
                          # print("DEBUG: Final article_candidates_df prepared with required columns and index.")

                else:
                    print("警告: テンプレート生成に成功した有効な記事候補がありませんでした。")
                    article_candidates_df = pd.DataFrame() # Ensure empty DataFrame


# Ensure article_candidates_df is available globally after this cell runs
# It is already declared implicitly by being assigned to in the global scope.
# print(f"DEBUG: Final article_candidates_df shape: {article_candidates_df.shape}") # Suppress verbose output


print("\n記事候補抽出と準備プロセス実行終了。")

"""# 記事候補生成② 4dc514cd"""

# This cell handles displaying candidate articles generated by the previous step (dbfc915c)
# and allows the user to select one candidate to proceed with.
# It saves the selected candidate's data to a temporary file for use in the next steps.

import ipywidgets as widgets
from IPython.display import display, clear_output
import pandas as pd
import json
import os
import traceback
# MODIFIED: Change import style to directly import datetime class
from datetime import datetime # Import datetime class from datetime module


print("--- 記事候補選択UIプロセス ---")

# Define the temporary file path for selected candidate data
TEMP_SELECTED_DATA_PATH = '/tmp/selected_candidate_data.json'

# Check if article_candidates_df is available and not empty
if 'article_candidates_df' not in globals() or not isinstance(globals()['article_candidates_df'], pd.DataFrame) or globals()['article_candidates_df'].empty:
    print("エラー: 記事候補データ (article_candidates_df) が見つからないか、または空です。")
    print("前のセル (dbfc915c) を実行し、記事候補が正しく選出されているか確認してください。")
    # Initialize an empty DataFrame to avoid errors in subsequent steps if this cell is run again
    article_candidates_df = pd.DataFrame()
else:
    # Use a copy to avoid SettingWithCopyWarning
    article_candidates_df = globals()['article_candidates_df'].copy()

    print(f"{len(article_candidates_df)} 件の記事候補が見つかりました。以下から1つを選択してください。")

    # Convert '日付' column to datetime objects, coercing errors
    if '日付' in article_candidates_df.columns:
        # Attempt to convert, handling potential errors by turning them into NaT
        article_candidates_df['日付'] = pd.to_datetime(article_candidates_df['日付'], errors='coerce')
        print("DEBUG: '日付' カラムを datetime 型に変換しました。")
    else:
        print("警告: '日付' カラムが article_candidates_df に見つかりません。日付情報の表示をスキップします。")
        # Add a placeholder column if missing to avoid errors later in formatting
        article_candidates_df['日付'] = pd.NaT # Add a column of NaT if missing


    # Prepare options for the dropdown
    # The dropdown should display a readable label (e.g., 課題ID + 課題タイトル + 日付 + record_textの冒頭)
    # The value should be the *index* of the row in article_candidates_df
    # Need to handle potential NaN/NaT in '日付'
    # Convert '日付' to string, handling NaT/NaN explicitly for display
    # Now that '日付' is datetime/NaT, the apply with strftime should work
    article_candidates_df['日付_str'] = article_candidates_df['日付'].apply(
        lambda x: x.strftime('%Y/%m/%d') if pd.notna(x) else '日付不明'
    )

    # Ensure 'record_text' and 'template_text' are treated as strings for display snippet and length
    article_candidates_df['record_text_str'] = article_candidates_df['record_text'].astype(str).fillna('')
    article_candidates_df['record_text_length'] = article_candidates_df['record_text_str'].str.len()

    article_candidates_df['template_text_str'] = article_candidates_df['template_text'].astype(str).fillna('')
    article_candidates_df['template_text_length'] = article_candidates_df['template_text_str'].str.len()


    # Create the display labels for the dropdown
    dropdown_options = [(
        f"候補 {i+1} | 課題ID: {row['課題ID']} - {row['課題タイトル']} (日付: {row['日付_str']}, 記録文字数: {int(row['record_text_length'])}, TPL文字数: {int(row['template_text_length'])})\n"
        f"記録内容冒頭: {row['record_text_str'][:100]}...\n"
        f"テンプレート冒頭: {row['template_text_str'][:100]}...", # Display first 100 characters of template
        index # Use the DataFrame index as the value (original df_kiroku index)
    ) for i, (index, row) in enumerate(article_candidates_df.iterrows())]

    # Ensure there are options to select from
    if not dropdown_options:
         print("エラー: 記事候補データは存在しますが、選択肢を作成できませんでした。データの形式を確認してください。")
         print("DEBUG: article_candidates_df columns:", article_candidates_df.columns)
         print("DEBUG: article_candidates_df head:\n", article_candidates_df.head())
    else:
        # Create the dropdown widget
        candidate_dropdown = widgets.Dropdown(
            options=dropdown_options,
            description='候補を選択:',
            disabled=False,
            layout=widgets.Layout(width='95%')
        )

        # Create the selection button
        select_button = widgets.Button(description='この候補を選択', button_style='success')

        # Output area to display confirmation or errors
        output_area = widgets.Output()

        # --- Custom JSON Serializer for datetime objects ---
        # Add a custom function to handle datetime serialization
        def serialize_for_json(obj):
            # MODIFIED: Use 'datetime' directly since 'datetime' class is imported
            if isinstance(obj, (datetime, pd.Timestamp)): # Check against datetime class and Timestamp
                return obj.isoformat() # Convert datetime/Timestamp to ISO 8601 string
            # Handle pandas NaT and Python None as JSON null
            elif pd.isna(obj): # This covers pandas NaT and numpy/pandas NaN
                return None # Represent NaN as null in JSON
            # Add other types if needed
            # If empty strings should be null, change '' to None here.
            # elif isinstance(obj, str) and obj.strip() == '':
            #     return None
            return obj

        # Function to handle button click
        def on_select_button_clicked(b):
            with output_area:
                clear_output(wait=True)
                selected_index = candidate_dropdown.value # Get the selected index
                print(f"DEBUG: Selected index from dropdown: {selected_index}")

                # Ensure the selected index is valid and exists in the DataFrame's index
                if selected_index in article_candidates_df.index:
                    # Get the selected row from the DataFrame using the index
                    selected_row = article_candidates_df.loc[selected_index] # Get the selected row (as a Series)

                    # Manually construct the dictionary with needed fields
                    # This avoids potential circular references from the Series object's internal structure.
                    selected_candidate_data = {
                        '課題ID': selected_row.get('課題ID'),
                        '課題タイトル': selected_row.get('課題タイトル'),
                        'record_text': selected_row.get('record_text'),
                        'template_text': selected_row.get('template_text'),
                        '日付': selected_row.get('日付'), # Include date, will be serialized by custom default
                        'selected_record_index': selected_index, # Explicitly include the original index
                        # Add any other necessary columns here that the next steps (af705a24, 6b45381f) might need
                        # e.g., '選手ID', '氏名', etc. based on the original df_kiroku structure and subsequent code.
                        # Let's add a few more commonly needed ones based on previous code.
                        '選手ID': selected_row.get('選手ID'),
                        '氏名': selected_row.get('氏名'),
                        '最新指導日': selected_row.get('最新指導日'),
                        '状態': selected_row.get('状態'),
                        '傾向タイプ': selected_row.get('傾向タイプ'),
                        'Form Ranger': selected_row.get('Form Ranger'),
                        '次回方針': selected_row.get('次回方針'),
                        'タグ': selected_row.get('タグ'),
                        '課題の概要': selected_row.get('課題の概要'),
                        # Note: 'record_text_str', 'record_text_length', '日付_str', 'template_text_str', 'template_text_length'
                        # are generated for UI display in this cell and are not typically needed in the saved data.
                        # So, they are excluded from the dictionary saved to the file.
                    }


                    # Check if necessary keys are present in the data to be saved
                    # These are the keys that af705a24 expects to load and are essential.
                    # Use the keys we are explicitly adding to the dictionary.
                    required_keys_for_save_check = ['課題ID', 'template_text', 'record_text', 'selected_record_index']
                    if not all(key in selected_candidate_data and selected_candidate_data.get(key) is not None for key in required_keys_for_save_check):
                         # Check for None values specifically
                         missing_or_none_keys = [key for key in required_keys_for_save_check if key not in selected_candidate_data or selected_candidate_data.get(key) is None]
                         print(f"エラー: 選択された候補データに必要なキー ({missing_or_none_keys}) が存在しないか値が None です。データを確認してください。")
                         print("DEBUG: Data intended for saving:", selected_candidate_data)
                         # Do not attempt to save if essential data is missing
                         return

                    # Check for essential text fields being empty strings after stripping
                    if not all(str(selected_candidate_data.get(key, '')).strip() != '' for key in ['課題ID', 'template_text', 'record_text']):
                        empty_text_keys = [key for key in ['課題ID', 'template_text', 'record_text'] if str(selected_candidate_data.get(key, '')).strip() == '']
                        print(f"警告: 選択された候補データの必須テキストフィールド ({empty_text_keys}) が空です。このまま保存しますが、次のステップで問題になる可能性があります。")
                        print("DEBUG: Data intended for saving:", selected_candidate_data)
                        # Continue saving but warn the user


                    print("DEBUG: 選択された候補データは必要なキーが含まれています。保存を試みます。")
                    # Save the selected data to a temporary JSON file
                    try:
                        with open(TEMP_SELECTED_DATA_PATH, 'w', encoding='utf-8') as f:
                            # Use the custom serializer for datetime objects
                            json.dump(selected_candidate_data, f, ensure_ascii=False, indent=4, default=serialize_for_json)

                        print(f"選択された候補 (課題ID: {selected_candidate_data.get('課題ID')}, 記録インデックス: {selected_candidate_data.get('selected_record_index')}) のデータを一時ファイルに保存しました。")
                        print(f"一時ファイル: {TEMP_SELECTED_DATA_PATH}")
                        print("\n次のセル (データ読み込み・変数準備: af705a24 or 9ddb9170) を実行してください。") # Updated guidance


                        # Make the global variable accessible in the next cell immediately (optional, file is primary)
                        # Note: This global variable might be less reliable than the file across cell executions sometimes.
                        global selected_candidate_data_global
                        selected_candidate_data_global = selected_candidate_data

                    except Exception as e:
                        # Report the specific error during saving
                        print(f"エラー: 選択候補データの一時ファイル保存に失敗しました: {e}")
                        print(traceback.format_exc())
                        print("グローバル変数にはセットされた可能性がありますが、不安定かもしれません。")
                        print("この場合、次のセルでエラーになる可能性があります。")


                else:
                    print("エラー: 無効な候補が選択されました。再度選択してください。")

        # Link the button click to the handler function
        select_button.on_click(on_select_button_clicked)

        # Display the UI elements
        display(candidate_dropdown)
        display(select_button)
        display(output_area)

print("\n記事候補選択UIプロセス実行終了。UIが表示されている場合は、候補を一つ選択してください。")

"""# 9ddb9170"""

# This block handles loading the data from the selected candidate saved by the UI (e.g., 4dc514cd)
# and preparing the global 'article_generation_data' variable for the next steps (like 6b45381f).
# It expects the selected candidate data, including the selected record index, to be
# saved in a temporary JSON file.

# Importing necessary libraries. Some might be redundant if already in global scope, but included for clarity.
import ipywidgets as widgets # Although not a UI cell, keep imports that might be needed if combined later
from IPython.display import display, clear_output, Image # Keep imports if image/data display is needed
import textwrap
import os
import time
# from openai import OpenAI # Not directly needed for just loading, but might be for follow-up
import json
import re
import traceback
import ast # Import ast for safe evaluation
import pandas as pd # Ensure pandas is imported

print("\n--- 記事データ読み込みと変数準備 ---")

# Global variable to store the final selection data for the next step (6b45381f)
# Initialize with None or empty structures
global article_generation_data
# MODIFIED: Initialize with default values including selected_record_index
article_generation_data = {
    'kadai_id': None,
    'template_text': None,
    'record_text': None,
    'article_title': None,
    'selected_images': [], # This should be populated by the image selection step (5a61dd18) BEFORE 6b45381f
    'selected_record_index': None # Key for selected record index, must come from the candidate selection step (4dc514cd)
}

# Define required keys in the data that *should* be loaded from the temporary file.
# This assumes the candidate selection UI cell (4dc514cd) saves these essential pieces of data.
required_loaded_keys = ['課題ID', 'template_text', 'record_text', 'selected_record_index']

# Define the temporary file path where the candidate selection UI cell (4dc514cd) saves data
TEMP_SELECTED_DATA_PATH = '/tmp/selected_candidate_data.json'

loaded_data = None
data_available = False # Flag to track if required data was successfully loaded

print(f"DEBUG: Attempting to load data from temporary file: {TEMP_SELECTED_DATA_PATH}")

if os.path.exists(TEMP_SELECTED_DATA_PATH):
    try:
        with open(TEMP_SELECTED_DATA_PATH, 'r', encoding='utf-8') as f:
            loaded_data = json.load(f)
            print("DEBUG: Successfully loaded data from temporary file.")

            # MODIFIED: Add debug print to show loaded data content
            print(f"DEBUG: Loaded data content (first 500 chars): {json.dumps(loaded_data, ensure_ascii=False)[:500]}...")
            print(f"DEBUG: Does loaded_data contain 'selected_record_index'? {'selected_record_index' in loaded_data}")
            if 'selected_record_index' in loaded_data:
                 print(f"DEBUG: Value of loaded_data['selected_record_index']: {loaded_data.get('selected_record_index')}")
            else:
                 print("WARNING: 'selected_record_index' is NOT in loaded_data from temporary file.")


            # Validate loaded data has all required keys and non-empty values for essential fields
            # Check for key existence and non-None values first for required_loaded_keys
            # Explicitly check if selected_record_index is not None after loading
            if isinstance(loaded_data, dict) and \
               all(key in loaded_data and loaded_data.get(key) is not None for key in required_loaded_keys) and \
               loaded_data.get('selected_record_index') is not None: # Explicit check for the index

                 # Now check for non-empty strings specifically for text/ID fields
                 if all(str(loaded_data.get(key, '')).strip() != '' for key in ['課題ID', 'template_text', 'record_text']):
                      # If all checks pass, data is considered available
                      data_available = True
                      print("DEBUG: Loaded data validated.")

                      # Explicitly assign loaded data to the global article_generation_data
                      # This ensures all required keys, including selected_record_index, are transferred.
                      article_generation_data['kadai_id'] = loaded_data.get('課題ID')
                      article_generation_data['template_text'] = loaded_data.get('template_text')
                      article_generation_data['record_text'] = loaded_data.get('record_text')
                      # Use '課題タイトル' from the loaded data as the initial article title
                      article_generation_data['article_title'] = loaded_data.get('課題タイトル', loaded_data.get('課題ID')) # Fallback to 課題ID if title missing
                      # Assign the loaded selected_record_index - this is required
                      article_generation_data['selected_record_index'] = loaded_data.get('selected_record_index')

                      # Note: selected_images will be populated by the image selection cell (5a61dd18)
                      # or potentially combined in a later cell before 6b45381f. This cell
                      # primarily ensures candidate details and index are loaded.

                      print("DEBUG: Loaded data assigned to article_generation_data.")
                      # MODIFIED: Add debug print to confirm value in article_generation_data
                      print(f"DEBUG: article_generation_data['selected_record_index'] set to: {article_generation_data.get('selected_record_index')}")

                 else:
                      # Identify which text/ID keys are empty strings
                      empty_text_keys = [key for key in ['課題ID', 'template_text', 'record_text'] if str(loaded_data.get(key, '')).strip() == '']
                      print(f"警告: 一時ファイルからデータを読み込めましたが、必須テキストフィールドが空です。空のキー: {empty_text_keys}")
                      # Data is incomplete, data_available remains False

            else:
                # Identify missing or None keys for better error message
                # Include selected_record_index in this check
                missing_or_none_keys = [
                    key for key in required_loaded_keys
                    if key not in loaded_data or loaded_data.get(key) is None
                ]
                # Also explicitly check if selected_record_index is None if it exists but is None
                if 'selected_record_index' in loaded_data and loaded_data.get('selected_record_index') is None and 'selected_record_index' not in missing_or_none_keys:
                     missing_or_none_keys.append('selected_record_index (value is None)')


                print(f"警告: 一時ファイルからデータを読み込めましたが、必要なキーが見つからないか値が None です。不足/Noneのキー: {{(missing_or_none_keys)}}") # Use {{}} to escape curly braces in f-string
                print(f"ファイル内容 (先頭500文字): {json.dumps(loaded_data, ensure_ascii=False)[:500]}...")
                # Data is incomplete, data_available remains False

    except json.JSONDecodeError:
        print(f"エラー: 一時ファイル '{TEMP_SELECTED_DATA_PATH}' のJSON形式が不正です。ファイル内容を確認してください。")
        print(f"ファイル内容 (先頭500文字):\n{open(TEMP_SELECTED_DATA_PATH, 'r', encoding='utf-8').read()[:500]}...")
        # data_available remains False
    except Exception as e:
        print(f"エラー: 一時ファイル '{TEMP_SELECTED_DATA_PATH}' の読み込み中に予期せぬエラーが発生しました: {e}")
        print(traceback.format_exc())
        # data_available remains False
else:
    print(f"エラー: 必須の一時ファイル '{TEMP_SELECTED_DATA_PATH}' が見つかりません。")
    # data_available remains False


# --- Final check: If required data is still not loaded, report error and stop processing ---
if not data_available:
    print(f"\nエラー: 記事本文生成に必要な基本データ (候補データ、インデックスなど) が見つからないか、形式が正しくありません。処理をスキップします。")
    # Provide guidance on the correct workflow, specifically mentioning saving selected_record_index in 4dc514cd
    print("原因として、前のステップ (記事候補選択UI セル `4dc514cd`) で、選択した候補のデータが一時ファイルに正しく保存されていない可能性があります。")
    print(f"特に、一時ファイル '{TEMP_SELECTED_DATA_PATH}' に、選択した記録データの元のインデックス (`selected_record_index`) が含まれている必要があります。")
    print("\n以下のステップを順番に実行してください:")
    print("1. セル `dbfc915c` (記事候補抽出)")
    print("2. **セル `4dc514cd` (記事候補選択UI) を実行し、候補を選択して「この候補を選択」ボタンをクリックしてください。この際、選択した記録データの元のインデックス (`selected_record_index`) が一時ファイルに保存されるように、そのセルのコードが正しいか確認してください。**")
    print("3. セル `3c6a0178` (タイトル選択)") # Assuming user runs this after candidate selection
    print("4. セル `5a61dd18` (画像選択)")   # Assuming user runs this after title selection
    print("5. セル `af705a24` (現在のセル) を実行し、データが正しく読み込まれるか確認")
    print("6. セル `6b45381f` (記事本文生成・投稿UI)")

    # Ensure article_generation_data remains empty or incomplete if data is not available
    # This prevents subsequent cells from running with partial data and causing worse errors.
    article_generation_data = {
        'kadai_id': None,
        'template_text': None,
        'record_text': None,
        'article_title': None,
        'selected_images': [],
        'selected_record_index': None
    }


print("\n記事データ読み込みと変数準備プロセス実行終了。データが正常に読み込まれていれば、次のステップに進んでください。")

"""# タイトル選択　3c6a0178"""

# This cell handles generating article title candidates and displaying a UI for selecting the final title.
# It assumes that 'article_generation_data' has been populated with selected candidate details
# by a previous step (e.g., from af705a24 or 9ddb9170 which loads from /tmp/selected_candidate_data.json).
# Image generation and selection are assumed to be handled in a separate cell (5a61dd18).
# It appears the user also expects an "Additional Instructions" field and a "Regenerate" button in this cell.
# The purpose of regeneration in this specific cell context (title selection) needs clarification,
# but the UI elements will be added as requested.

import ipywidgets as widgets
from IPython.display import display, clear_output # Keep display and clear_output

import textwrap
import os
import time
from openai import OpenAI # Keep OpenAI for title generation
import re # Keep re for parsing generated titles
import traceback # Keep traceback for error info


# Assuming article_generation_data is populated by a previous cell (af705a24 or 9ddb9170)
# It should contain keys like 'kadai_id', 'template_text', 'record_text', 'article_title' (initial)
# and importantly, 'selected_record_index'.
global article_generation_data # Declare global variable

print("\n--- 記事タイトル候補生成・選択 ---")

# Check if article_generation_data is available and has essential keys populated
required_data_keys = ['kadai_id', 'template_text', 'record_text', 'selected_record_index']
data_available = True
if 'article_generation_data' not in globals() or not isinstance(globals()['article_generation_data'], dict):
    print("エラー: 記事生成データ (article_generation_data) が見つかりません。")
    data_available = False
else:
    # Check for essential keys and non-None values
    for key in required_data_keys:
        if key not in article_generation_data or article_generation_data.get(key) is None:
            # Explicitly check if selected_record_index is None, which is a specific error case
            if key == 'selected_record_index' and article_generation_data.get(key) is None:
                 print(f"エラー: article_generation_data に必須キー '{key}' が見つからないか、値が None です。前のステップ (`af705a24` または再生成されたセル) を確認してください。")
            else:
                 print(f"エラー: article_generation_data に必須キー '{key}' が見つからないか、値が None です。")
            print(f"DEBUG: article_generation_data content: {article_generation_data}")
            data_available = False
            break
    # Also check if essential text fields are empty strings after stripping
    if all(key in article_generation_data for key in ['kadai_id', 'template_text', 'record_text', 'article_title']):
         if any(str(article_generation_data.get(key, '')).strip() == '' for key in ['kadai_id', 'template_text', 'record_text', 'article_title']):
              empty_keys = [key for key in ['kadai_id', 'template_text', 'record_text', 'article_title'] if str(article_generation_data.get(key, '')).strip() == '']
              print(f"警告: article_generation_data の必須フィールド ({empty_keys}) が空です。タイトル生成に影響する可能性があります。")
              # Decide if this should prevent execution - for now, let's allow but warn


if not data_available:
    print("必要な記事生成データが不足しているため、タイトル候補生成・選択プロセスをスキップします。")
    print("以下のステップを順番に実行してください:")
    print("1. セル `dbfc915c` (記事候補抽出)")
    print("2. セル `4dc514cd` (記事候補選択UI) を実行し、候補を選択してボタンをクリック")
    print("3. セル `af705a24` または再生成されたセル (例: 9ddb9170) を実行し、データが正しく読み込まれるか確認")
    print("4. セル `3c6a0178` (現在のセル) を実行し、タイトルを確定") # Corrected guidance
    print("5. セル `5a61dd18` (画像選択)")
    print("6. セル `6b45381f` (記事本文生成・投稿UI)")
    # Stop processing if data is not available
else:
    # Wrap the main logic in a try block
    try:
        # Retrieve selected candidate data from the global variable
        selected_kadai_id = article_generation_data.get('kadai_id')
        selected_template_text = article_generation_data.get('template_text')
        selected_record_text = article_generation_data.get('record_text')
        initial_article_title = article_generation_data.get('article_title', '') # Get initial title if available
        selected_record_index = article_generation_data.get('selected_record_index')


        print(f"対象課題ID: {selected_kadai_id}")
        print(f"使用する記録行のインデックス (df_kiroku): {selected_record_index}")


        # Display the selected template and record data again for context
        print(f"\n---- 使用するテンプレート (課題ID: {selected_kadai_id}) ----\n")
        display(widgets.Textarea(value=selected_template_text, layout=widgets.Layout(width='95%', height='200px'), disabled=True))
        print(f"\n---- 使用する記録データ全文 (df_kiroku index: {selected_record_index}) ----\n")
        display(widgets.Textarea(value=selected_record_text, layout=widgets.Layout(width='95%', height='200px'), disabled=True))
        print("---------------------------------------------\n")


        # --- Title Generation ---
        title_candidates = [] # List to hold generated title options
        openai_client = None # Initialize OpenAI client
        title_gen_error_message = None # Initialize error message variable

        print("\n--- 記事タイトル候補を生成中 ---")

        # Initialize OpenAI client for title generation
        try:
            api_key = os.getenv("OPENAI_API_KEY")
            if not api_key:
                print("エラー: 環境変数 'OPENAI_API_KEY' が設定されていません。タイトル候補生成をスキップします。")
                title_gen_error_message = "OpenAI APIキーが設定されていません。"
                # Set client to None so generation is skipped
            else:
                openai_client = OpenAI(api_key=api_key)
                # print("DEBUG: OpenAI client initialized for title generation.")
        except Exception as e:
            print(f"エラー: OpenAIクライアントの初期化に失敗しました: {e}。タイトル候補生成をスキップします。")
            title_gen_error_message = f"OpenAIクライアント初期化エラー: {e}"
            openai_client = None

        # Define the main generation prompt template
        # Include instructions for tags and format
        # This prompt is for TITLE generation only in this cell
        title_gen_prompt_template = textwrap.dedent("""
以下の記事テンプレートを元に、記事のタイトル候補を3つ生成してください。
テンプレートの「仮タイトル」や「切り口」、「構成案」などを参考に、読者の興味を引くような、具体的で示唆的なタイトルを提案してください。
タイトルは、テンプレートの読者タイプ（「指導者」「保護者」「選手」）に合わせて調整してください。
「指導者」または「保護者」向けのタイトルは、テニス以外のスポーツや一般的な文脈にも応用できるような汎用的な視点を含めるように工夫してください。
「保護者」「選手」向けのタイトルは、あまり硬すぎたり、専門的にならないようにしてください。提案するタイトルは、具体的で、内容が伝わりやすく、SEOも意識したキーワードを含めてください。

【記事テンプレート】:
{template_text}

【指導記録（参考情報）】:
{record_text}

【要求】
- 3つの異なるタイトル案を提案してください。
- 各タイトル案は、読者の関心を引き、クリックしたくなるようなものにしてください。
- タイトル案はMarkdownのリスト形式で出力してください。（例: - タイトル案1\n- タイトル案2\n...）
- タイトル案以外には何も含めないでください。
{additional_instructions}
""").strip() # Added {additional_instructions} placeholder


        # Function to generate title candidates using OpenAI
        # MODIFIED: Added optional additional_instructions parameter for title regeneration
        def generate_title_candidates_with_openai(article_title, template_text, record_text, openai_client, additional_instructions=None):
             """Generates article title candidates using OpenAI based on provided data and instructions."""
             print("DEBUG: generate_title_candidates_with_openai called.")
             if openai_client is None:
                  print("ERROR: OpenAI client not available for generation.")
                  return [], "OpenAIクライアントが利用できません。"

             # Prepare prompt for title generation
             full_prompt = title_gen_prompt_template.format(
                 article_title=article_title, # Include title in prompt for context if needed, though maybe less relevant for initial title gen
                 template_text=template_text,
                 record_text=record_text,
                 additional_instructions=f"\n{additional_instructions.strip()}" if additional_instructions and additional_instructions.strip() else "" # Format instructions
             )

             print("DEBUG: Sending title prompt to OpenAI API...")
             try:
                  completion_response = openai_client.chat.completions.create(
                      model="gpt-4o-mini", # Or another suitable model
                      messages=[
                          {"role": "system", "content": "あなたは魅力的なブログ記事タイトルを生成するプロのライターです。"},
                          {"role": "user", "content": full_prompt}
                      ],
                      max_tokens=300, # Adjust token limit for titles
                      temperature=0.7 # Adjust creativity
                  )

                  if completion_response.choices and completion_response.choices[0].message and completion_response.choices[0].message.content:
                      raw_titles_output = completion_response.choices[0].message.content.strip()
                      print("DEBUG: Raw title generation output:\n", raw_titles_output)

                      # Parse the generated titles (expecting Markdown list)
                      # Split by lines and filter out empty lines, remove list markers (- )
                      generated_titles_list = [re.sub(r'^\s*[-*+]\s*', '', line).strip() for line in raw_titles_output.split('\n') if line.strip()]
                      print(f"DEBUG: Generated {len(generated_titles_list)} title candidates.")

                      return generated_titles_list, None # Return list of titles and no error message

                  else:
                      print("WARNING: Title generation API response was empty.")
                      return [], "OpenAIからのタイトル生成応答が空でした。"

             except Exception as api_e:
                  print(f"エラー: Title generation API call failed: {api_e}")
                  print(traceback.format_exc())
                  return [], f"タイトル生成APIエラー: {api_e}"


        # Initial generation attempt
        if openai_client:
             title_candidates, title_gen_error_message = generate_title_candidates_with_openai(
                 initial_article_title, selected_template_text, selected_record_text, openai_client
             )
             if title_gen_error_message:
                  title_candidates = ["タイトル生成失敗"] # Use placeholder on failure
                  print(f"警告: タイトル候補生成に失敗しました: {title_gen_error_message}")
             else:
                  print("タイトル候補を生成しました。")
        else:
            title_candidates = ["タイトル生成スキップ"] # Use placeholder if client not available
            print("警告: OpenAIクライアントが利用できないため、タイトル候補生成はスキップされました。")


        # --- Title Selection UI ---
        output_area_title_selection_ui = widgets.Output() # Use a dedicated output area for the selection UI
        display(output_area_title_selection_ui)

        # Define widgets outside the click handler so they persist and can be updated
        # MODIFIED: Corrected variable name to candidate_dropdown
        candidate_dropdown = widgets.Dropdown(description='記事タイトルを選択:')
        manual_title_input = widgets.Textarea(placeholder='手動でタイトルを入力してください', description='手動入力:')
        final_title_input = widgets.Textarea(placeholder='使用する最終的な記事タイトルを確認・編集してください', description='最終タイトル:')
        additional_instructions_textarea = widgets.Textarea(
             value='',
             placeholder='例: 「〇〇の点をさらに詳しく」「読者への問いかけを追加」「トーンをより親しみやすく」など、タイトル再生成のための指示を入力', # Adjusted placeholder text
             description='追加生成指示:', # Added description
             layout=widgets.Layout(width='95%', height='80px')
        )
        regenerate_button = widgets.Button(description='タイトル候補を再生成', button_style='primary') # Adjusted button text
        proceed_to_image_button_indicator = widgets.Button(description='画像選択に進む (タイトル確定後に次のセルを実行)', button_style='info', disabled=True) # Make disabled


        # Function to update the title dropdown options
        def update_title_dropdown(candidates_list):
            print("DEBUG: update_title_dropdown called.")
            # Prepare options for the dropdown
            title_options = [(f"候補 {i+1}: {item}", item) for i, item in enumerate(candidates_list) if item not in ["タイトル生成スキップ", "タイトル候補生成失敗", "タイトル候補生成エラー"]]
            manual_entry_label = "上記以外を手動で入力"
            manual_entry_value = "manual_entry_" + str(time.time()) # Unique value for manual entry
            title_options.append((manual_entry_label, manual_entry_value))

            # Update dropdown options
            candidate_dropdown.options = title_options

            # 修正: ここで変数名を正しくする
            current_initial_value = initial_article_title if initial_article_title and initial_article_title.strip() != '' else (candidates_list[0] if candidates_list and candidates_list[0] not in ["タイトル生成スキップ", "タイトル候補生成失敗", "タイトル候補生成エラー"] else manual_entry_value)

            valid_option_values = [val for label, val in title_options]

            # If the current initial value is not in the new options (excluding manual entry), default to manual entry
            if current_initial_value != manual_entry_value and current_initial_value not in [val for label, val in title_options if val != manual_entry_value]:
                  print(f"DEBUG (update_dropdown): Initial value '{current_initial_value}' not in new candidates. Defaulting to manual entry.")
                  # Set dropdown value to manual entry, and pre-fill manual input with the original initial value
                  candidate_dropdown.value = manual_entry_value
                  manual_title_input.value = current_initial_value
                  manual_title_input.disabled = False
                  final_title_input.value = current_initial_value # Also update final input
            else:
                  # Try to set the value to the determined initial value (either original, first new candidate, or manual entry)
                  # Need to ensure the value exists in the new options list before setting
                  if current_initial_value in valid_option_values:
                      candidate_dropdown.value = current_initial_value
                      # Trigger the change handler manually to update manual/final fields
                      on_title_selection_changed({'new': current_initial_value})
                  elif manual_entry_value in valid_option_values: # Fallback to setting manual entry if initial value isn't valid
                      candidate_dropdown.value = manual_entry_value
                       # Trigger the change handler manually to update manual/final fields
                      on_title_selection_changed({'new': manual_entry_value})
                  else:
                       print("DEBUG (update_dropdown): Cannot set initial dropdown value, defaulting to first option if available.")
                       if title_options:
                           candidate_dropdown.value = title_options[0][1]
                           on_title_selection_changed({'new': title_options[0][1]})
                       else:
                           print("WARNING: No title options available to set dropdown value.")


            print("DEBUG: Dropdown options updated and value set.")


        # --- Display UI elements ---
        with output_area_title_selection_ui:
             # clear_output(wait=True) # Decide if clearing is desired
             print("\n--- 記事タイトルを選択してください ---")
             print("DEBUG (Title Selection UI Display): Displaying dropdown...")
             # MODIFIED: Corrected variable name to candidate_dropdown
             display(candidate_dropdown)
             print("DEBUG (Title Selection UI Display): Displaying manual input...")
             display(manual_title_input)
             print("\n--- 使用する最終的な記事タイトル ---")
             print("DEBUG (Title Selection UI Display): Displaying final title input...")
             display(final_title_input)
             # MODIFIED: Display Additional Instructions and Regenerate Button
             print("\n**追加の生成指示 (タイトル候補):**")
             print("DEBUG (Title Selection UI Display): Displaying additional instructions textarea...") # Added debug print
             display(additional_instructions_textarea)
             print("DEBUG (Title Selection UI Display): Displaying regenerate button...") # Added debug print
             display(regenerate_button)
             print("\n--- 次のステップ ---")
             print("DEBUG (Title Selection UI Display): Displaying proceed button indicator...")
             display(proceed_to_image_button_indicator)
             print("DEBUG (Title Selection UI Display): Finished displaying UI elements.") # Added debug print


        # Store the final_title_input widget in a global variable for access in the next cell (5a61dd18)
        # This allows the next cell to read the user's final chosen/entered title.
        global final_title_input_global
        final_title_input_global = final_title_input
        print("DEBUG (Title Selection UI): 'final_title_input_global' stored in global scope.")


        # --- Observer functions to update manual input state and final_title_input value ---

        def on_title_selection_changed(change):
            print(f"DEBUG (Title Selection UI): Dropdown changed. New value: {change['new']}")
            selected_value = change['new'] # This is the title string or manual_entry_value_to_use
            # Find the correct manual_entry_value that was set when dropdown options were last updated
            current_manual_entry_value = next((val for label, val in candidate_dropdown.options if label.startswith('上記以外を手動で入力')), "manual_entry_fallback") # Fallback value


            if selected_value == current_manual_entry_value:
                manual_title_input.disabled = False
                # Don't clear manual input if it already contains a value from initial_article_title pre-fill
                # manual_title_input.value = "" # Clear manual input if previously used
                final_title_input.value = manual_title_input.value # Set final title to manual input value
                print("DEBUG (Title Selection UI): Manual entry selected. Manual input enabled. Final title set to manual input.")
            else:
                manual_title_input.disabled = True
                manual_title_input.value = "" # Clear manual input when a candidate is selected
                final_title_input.value = selected_value # Update final title with selected candidate's title
                print(f"DEBUG (Title Selection UI): Title candidate selected: '{selected_value}'. Manual input disabled. Final title updated.")

        # Link manual input to final_title_input value when user types
        def update_final_title_from_manual(change):
            print(f"DEBUG (Title Selection UI): Manual input changed. New value: {change['new']}")
            # Ensure manual input is not disabled before updating final title
            if not manual_title_input.disabled:
                final_title_input.value = change['new']
                print(f"DEBUG (Title Selection UI): Final title updated from manual input: '{change['new']}'")


        # --- Regenerate Button Click Handler ---
        def on_regenerate_button_clicked(b):
             print("\n--- タイトル候補再生成ボタンがクリックされました ---")
             if openai_client is None:
                  print("エラー: OpenAIクライアントが利用できないため、タイトル候補を再生成できません。APIキーを確認してください。")
                  return

             current_additional_instructions = additional_instructions_textarea.value # Get instructions

             with output_area_title_selection_ui:
                  # clear_output(wait=True) # Decide if clearing is desired
                  print("\n--- タイトル候補再生成中 ---")
                  # Optionally display a loading indicator

             # Perform regeneration
             new_title_candidates, regen_error_message = generate_title_candidates_with_openai(
                 final_title_input.value, # Use the current final title for context
                 selected_template_text,
                 selected_record_text,
                 openai_client,
                 current_additional_instructions # Pass additional instructions
             )

             with output_area_title_selection_ui:
                  if regen_error_message:
                       print(f"タイトル候補再生成に失敗しました: {regen_error_message}")
                       # Optionally add a placeholder title to the list
                       new_title_candidates = ["タイトル再生成エラー"] # Use placeholder
                  else:
                       print("タイトル候補の再生成が完了しました。")
                       # Clear instructions after successful regeneration?
                       # additional_instructions_textarea.value = '' # Optional


             # Update the dropdown options and potentially the selected value
             update_title_dropdown(new_title_candidates)

             print("DEBUG: タイトル候補再生成処理完了。")


        # Observe changes in the dropdown and manual input
        # MODIFIED: Corrected variable name to candidate_dropdown
        candidate_dropdown.observe(on_title_selection_changed, names='value')
        manual_title_input.observe(update_final_title_from_manual, names='value')
        regenerate_button.on_click(on_regenerate_button_clicked) # Link regenerate button


        # Initial update of dropdown options and value
        update_title_dropdown(title_candidates) # Use the initially generated candidates


    # Corrected indentation for except blocks
    except NameError as ne:
         print(f"エラー: 必要な関数やクラスが見つかりません: {ne}. 適切なセルを実行してください。")
         print(traceback.format_exc())
    except Exception as e:
         print(f"記事タイトル候補生成・選択処理中に予期せぬエラーが発生しました: {e}")
         print(traceback.format_exc()) # Use traceback.format_exc() for standard format


print("\n記事タイトル候補生成・選択プロセス実行終了。UIが表示されている場合は操作してください。")

"""# 画像選択　5a61dd18"""

# --- 画像生成と画像選択UI ---
# このセルは、生成されたタイトル候補に基づいて画像を生成し、画像選択UIを表示します。
# 元のセル af705a24 から画像生成部分と画像選択UI部分を抽出・統合しました。
# 前のセル (記事タイトル候補生成・選択UI) で生成された title_candidates、
# および global article_generation_data (に格納された kadai_id, template_text, record_text, article_title) が必要です。
# このセルは、選択された最終画像を global article_generation_data に格納します。

import ipywidgets as widgets
from IPython.display import display, clear_output, Image
import textwrap
import os
import time
from openai import OpenAI # Ensure OpenAI is imported
import json
import re
import traceback

print("\n--- 画像生成と画像選択UIプロセス ---")

# Declare global variables at the top level of the script
global generated_titles_with_images_global
global all_generated_images_global
global article_generation_data # Need to access and update article_generation_data


# Check if required data is available from the previous step (Title Generation & Selection UI)
required_data_for_image_gen = {
    'article_generation_data': (True, dict), # Check if it exists and is a dict
    'title_candidates': (True, list) # Check if it exists and is a list
}

data_available = True
missing_data_info = []

for var_name, (is_required, expected_type) in required_data_for_image_gen.items():
    if var_name not in globals():
        data_available = False
        missing_data_info.append(f"'{var_name}' (見つかりません)")
    elif not isinstance(globals()[var_name], expected_type):
        data_available = False
        missing_data_info.append(f"'{var_name}' (予期しない型: {type(globals()[var_name]).__name__}, 期待: {expected_type.__name__})")
    elif expected_type == list and not globals()[var_name]:
         # For title_candidates, an empty list is a valid case (e.g., API failed)
         print(f"警告: '{var_name}' リストは空です。画像生成はスキップされる可能性があります。")
         # Data is technically available, just empty. Don't set data_available to False here.
    elif expected_type == dict and (not globals()[var_name] or not all(key in globals()[var_name] for key in ['kadai_id', 'template_text', 'record_text', 'article_title'])):
        data_available = False
        missing_data_info.append(f"'{var_name}' (必要なキーが不足しています)")


if not data_available:
    print(f"エラー: 画像生成・選択UIに必要なデータが見つからないか、形式が正しくありません。")
    print(f"不足している/不正確なデータ: {', '.join(missing_data_info)}")
    print("前のセル（記事タイトル候補生成とタイトル選択UI）が正常に実行され、タイトルが選択・入力されているか確認してください。")

    print("\n画像生成と画像選択UIプロセス実行終了。UIは表示されません。")
    # Set global image lists to empty if essential data is missing
    generated_titles_with_images_global = []
    all_generated_images_global = []

else:
    # Data is available, proceed with image generation and UI display

    # Retrieve data from global article_generation_data and title_candidates
    selected_kadai_id = article_generation_data.get('kadai_id')
    selected_template_text = article_generation_data.get('template_text')
    selected_record_text = article_generation_data.get('record_text')
    final_article_title = article_generation_data.get('article_title') # Get the selected/input title
    title_candidates = globals()['title_candidates'] # Get the list of generated titles from the previous cell


    # Initialize generated_titles_with_images and all_generated_images lists
    # generated_titles_with_images is used to group images by the title they were generated for (might be useful for reference)
    generated_titles_with_images_global = [] # Initialize as empty list
    all_generated_images_global = [] # Initialize as empty list

    openai_client = None # Initialize OpenAI client

    # Initialize OpenAI client (needed for image generation)
    try:
         api_key = os.getenv("OPENAI_API_KEY")
         if not api_key:
             print("エラー: 環境変数 'OPENAI_API_KEY' が設定されていません。画像生成をスキップします。")
             # Set client to None so image generation is skipped
         else:
             openai_client = OpenAI(api_key=api_key)
             # print("DEBUG: OpenAI client initialized for image generation.")
    except Exception as e:
         print(f"エラー: OpenAIクライアントの初期化に失敗しました: {e}。画像生成をスキップします。")
         openai_client = None


    # --- Generate Images for Each Title Candidate ---
    # Only attempt image generation if title candidates were successfully generated AND client is available
    image_generation_attempts = 0
    image_generation_success_count = 0
    image_generation_failed_messages = []

    # Use the list of title candidates generated in the previous step for image generation
    titles_to_generate_images_for = title_candidates

    if titles_to_generate_images_for and openai_client: # Added check for openai_client
        print("\n--- 各タイトル候補の画像生成を開始します ---")
        base_image_prompt = "スポーツの指導、成長、学びに関連するシーンのイラスト。ポジティブな雰囲気、手描きのイラスト調。"
        # Use the selected_template_text from article_generation_data to extract reader type
        reader_type_match = re.search(r"【読者タイプ】:\s*(.+?)向け", selected_template_text)
        # Ensure reader_type is defined even if regex fails
        reader_type = reader_type_match.group(1).strip() if reader_type_match else ""


        # Ensure generate_image_with_dalle function is defined
        if 'generate_image_with_dalle' not in globals() or not callable(generate_image_with_dalle):
            print("エラー: `generate_image_with_dalle` 関数が定義されていません。適切なヘルパー関数セルを実行してください。画像生成をスキップします。")
        else:
            # Loop through title candidates to generate images
            generated_titles_with_images_local = [] # Local list for the loop
            all_generated_images_local = [] # Local list for the loop

            for i, title in enumerate(titles_to_generate_images_for):
                print(f"\n--- タイトル候補 {i+1}: '{title}' の画像生成 ---")
                images_for_title = [] # Images specific to this title

                refined_image_prompt_parts = [base_image_prompt]
                refined_image_prompt_parts.append(f"記事タイトル「{title}」の内容を反映したイメージ。")
                if reader_type:
                    refined_image_prompt_parts.append(f"{reader_type}向けの読者の興味を引くような描写。")
                refined_image_prompt_parts.append("具体的なスポーツ指導の場面や、選手が成長・学んでいる様子を描写してください（例: コーチと選手が対話している様子、練習中のワンシーン、課題を克服するアスリート）。")
                current_image_prompt = " ".join(refined_image_prompt_parts).strip()

                # Generate 1 image per title as requested
                num_images_per_title = 1
                for img_index in range(num_images_per_title):
                    image_generation_attempts += 1
                    print(f"  画像 {img_index+1}/{num_images_per_title} 生成中...")
                    # Call the generate_image_with_dalle function defined in 5b6bdb71
                    image_result = generate_image_with_dalle(current_image_prompt)
                    if image_result["status"] == "success":
                        # Add the title the image was generated for to the image_result
                        image_result['generated_for_title'] = title
                        images_for_title.append(image_result) # Store the full result dict
                        all_generated_images_local.append(image_result) # Add to the list of ALL images
                        image_generation_success_count += 1
                        print(f"  画像 {img_index+1} 生成成功。")
                    else:
                        print(f"  画像 {img_index+1} 生成失敗: {image_result['message']}")
                        image_generation_failed_messages.append(f"画像生成失敗 (タイトル: '{title}'): {image_result['message']}")
                        # Let's skip failed images from the selection list for now.

                # Store the title and its generated images (even if the list is empty due to failures)
                generated_titles_with_images_local.append({
                    "title": title,
                    "images": images_for_title
                })

            print("\n--- 全てのタイトル候補の画像生成が完了しました ---")
            print(f"画像生成試行回数: {image_generation_attempts}")
            print(f"成功した画像数: {image_generation_success_count}")
            if image_generation_failed_messages:
                print("画像生成失敗の詳細:")
                for msg in image_generation_failed_messages:
                     print(f"- {msg}")

            # Assign local lists to global variables AFTER the loop
            generated_titles_with_images_global = generated_titles_with_images_local
            all_generated_images_global = all_generated_images_local

            print(f"DEBUG (Image Gen): 生成されたタイトル候補と画像のリストの構造 (generated_titles_with_images_global):")
            for item in generated_titles_with_images_global:
                 print(f"- Title: '{item['title']}'")
                 print(f"  Images Generated: {len(item['images'])}")
                 for img in item['images']:
                     print(f"    - URL: {img['url'][:50]}... Status: {img['status']}")

            print(f"DEBUG (Image Gen): 全て生成された画像のリスト (all_generated_images_global): {len(all_generated_images_global)}枚")
            # Print summary of all images
            for i, img in enumerate(all_generated_images_global):
                 print(f"  画像 {i+1}: Status: {img.get('status', 'N/A')}, For Title: '{img.get('generated_for_title', 'N/A')[:30]}...'")


            print("DEBUG (Image Gen): 'generated_titles_with_images_global' and 'all_generated_images_global' stored in global scope.")
    else:
         print("\n--- 画像生成スキップ ---")
         if not titles_to_generate_images_for: # Use the list derived from title_candidates
             print("タイトル候補が生成されなかったため、画像生成はスキップされました。")
         elif not openai_client:
             print("OpenAIクライアントが初期化されていないため、画像生成はスキップされました。APIキーを確認してください。")
         # No need to explicitly set global image lists to empty here, as they are initialized at the start of the block


    # --- Display generated images and UI for selection ---
    print("DEBUG: --- Attempting to display Image Selection UI ---") # Debug print before UI display
    output_area_selection_ui = widgets.Output() # Use a dedicated output area for the final selection UI
    display(output_area_selection_ui)

    with output_area_selection_ui:
        clear_output(wait=True)
        print("DEBUG (Image UI): Inside output_area_selection_ui context for displaying image selection UI.")

        # --- Display Image UI (Previews and Radio Buttons) ONLY if any images were successful ---
        image_selection_radiobuttons = None
        image_preview_container = None
        selected_image_preview_output = None # Initialize here

        # Access the global list which is now guaranteed to be populated (or empty)
        successful_images_info = [img for img in all_generated_images_global if img.get('status') == 'success' and img.get('url')]

        if successful_images_info:
            print("\n--- 生成された画像候補 ---")
            print(f"DEBUG (Image UI): Displaying UI for {len(successful_images_info)} successful images.")
            # Create image selection UI (e.g., RadioButtons with image previews)
            image_outputs = [] # Use Output widgets for previews
            image_radio_options = [] # List of (label, value) for RadioButtons


            # Populate image_radio_options and create corresponding Output widgets from successful images
            for i, img_info in enumerate(successful_images_info):
                 # Use the image URL as the value
                 label = f"画像 {i + 1} (タイトル: '{img_info.get('generated_for_title', 'N/A')[:30]}...') "
                 value = img_info['url'] # Use URL as the value
                 image_radio_options.append((label, value))
                 # Create a corresponding Output widget
                 image_outputs.append(widgets.Output())

            print(f"DEBUG (Image UI): image_radio_options populated with {len(image_radio_options)} options.")

            # Display image previews below the radio buttons
            print("\n--- 画像プレビュー ---")
            # Create a container to hold all image outputs
            # Use VBox for vertical arrangement
            image_preview_container = widgets.VBox(image_outputs)
            display(image_preview_container)

            # Proceed to display image selection UI (RadioButtons)
            # Use the list of tuples for options
            # Ensure the default value is a valid option if options exist
            default_image_value = image_radio_options[0][1] if image_radio_options else None
            image_selection_radiobuttons = widgets.RadioButtons(
                options=image_radio_options,
                description='画像を選択:',
                disabled=False,
                value=default_image_value, # Set default value
                layout=widgets.Layout(width='95%', margin='0px 0px 10px 0px')
            )

            # Display the RadioButtons AFTER the image previews
            display(image_selection_radiobuttons)


            # --- Dedicated Output for Selected Image Preview ---
            print("\n--- 選択中の画像プレビュー ---")
            selected_image_preview_output = widgets.Output()
            display(selected_image_preview_output)


            # Function to update image previews for all generated images
            # This is slightly redundant with the selected preview, but keeps the original preview layout
            def update_all_image_previews():
                print("DEBUG (Image UI): update_all_image_previews called.")
                # Clear the content of each individual output widget
                for output_widget in image_outputs:
                     with output_widget:
                          clear_output(wait=True)

                print("\n--- 画像プレビュー ---")
                # Iterate through the *successful* image info and display in corresponding output widgets
                for i, img_info_to_display in enumerate(successful_images_info):
                     if i < len(image_outputs):
                          img_output_widget = image_outputs[i]
                          with img_output_widget:
                               try:
                                    display(Image(url=img_info_to_display['url'], width=200))
                                    print(f"DEBUG (Image UI): Displayed image {i+1} in all previews.")
                               except Exception as display_e:
                                    print(f"画像の表示に失敗しました: {display_e}")
                                    print(f"URL: {img_info_to_display['url']}")
                                    print(f"DEBUG (Image UI): Failed to display image {i+1} in all previews.")


            # Display initial image previews for all generated images
            update_all_image_previews()


        else:
            print("\n--- 画像プレビューと選択UI ---")
            print("画像生成に成功した画像がないため、画像プレビューと選択UIは表示されません。")
            image_selection_radiobuttons = None # Explicitly set to None
            image_preview_container = None # Explicitly set to None
            selected_image_preview_output = None # Explicitly set to None


        # --- Observer function to update global article_generation_data with selected image ---

        def update_article_generation_data_with_image():
             print("DEBUG (Observer): Updating global article_generation_data (Image)...")
             global article_generation_data

             # Capture current selected image info
             current_selected_image_info = None
             current_selected_images_for_body_gen = [] # This list will contain the selected image info dict

             if image_selection_radiobuttons is not None and image_selection_radiobuttons.value is not None:
                  selected_image_url = image_selection_radiobuttons.value
                  print(f"DEBUG (Observer): Selected image URL from RadioButtons: {selected_image_url[:50]}...")
                  # Find the full image info dict for the selected URL from all_generated_images_global
                  current_selected_image_info = next((img for img in all_generated_images_global if img.get('url') == selected_image_url), None)

                  if current_selected_image_info:
                      print(f"DEBUG (Observer): Found full info for selected image. Status: {current_selected_image_info.get('status')}")
                      current_selected_images_for_body_gen = [current_selected_image_info] # Store the selected image info in a list
                      # Update the dedicated selected image preview if the output widget exists
                      if selected_image_preview_output is not None:
                           with selected_image_preview_output:
                                clear_output(wait=True)
                                try:
                                     print("選択中の画像:")
                                     display(Image(url=current_selected_image_info['url'], width=300)) # Display larger preview
                                     print("DEBUG (Observer): Updated selected image preview.")
                                except Exception as display_e:
                                     print(f"選択画像の表示に失敗しました: {display_e}")
                                     print(f"URL: {current_selected_image_info['url']}")
                                     print("DEBUG (Observer): Failed to display image {i+1} in selected preview.")
                  else:
                      print("DEBUG (Observer): Could not find full info for selected image URL.")
                      if selected_image_preview_output is not None:
                           with selected_image_preview_output:
                                clear_output(wait=True)
                                print("選択された画像の情報が見つかりません。")
                                print("DEBUG (Observer): Cleared selected image preview.")
             else:
                  print("DEBUG (Observer): No image selected or no image radio buttons available.")
                  if selected_image_preview_output is not None:
                       with selected_image_preview_output:
                            clear_output(wait=True)
                            print("画像が選択されていません。")
                            print("DEBUG (Observer): Cleared selected image preview.")


             # Update the global variable, preserving previously set keys
             article_generation_data['selected_images'] = current_selected_images_for_body_gen

             print(f"DEBUG (Observer): article_generation_data updated (Image):")
             print(f"  article_title: '{article_generation_data.get('article_title', 'N/A')}'") # Keep the title from previous step
             print(f"  selected_images count: {len(article_generation_data.get('selected_images', []))}")


        # Observe changes in the image selection radio buttons if they exist
        if image_selection_radiobuttons is not None:
             def on_image_selection_changed(change):
                  print(f"DEBUG (Image UI): Image RadioButtons changed. New value: {change['new']}")
                  # Call the update function after the image selection changes
                  update_article_generation_data_with_image()

             image_selection_radiobuttons.observe(on_image_selection_changed, names='value')

             # Trigger initial state update for selected image preview and global data
             print(f"DEBUG (Image UI): Triggering initial image UI and data update with value: {image_selection_radiobuttons.value}")
             on_image_selection_changed({'new': image_selection_radiobuttons.value})
        else:
             print("DEBUG (Image UI): Image radio buttons do not exist, skipping initial image update trigger.")
             # Even if no images were generated/selected, ensure selected_images in global data is an empty list
             if 'selected_images' not in article_generation_data or not isinstance(article_generation_data['selected_images'], list):
                  article_generation_data['selected_images'] = []
             print(f"DEBUG (Image UI): Initial article_generation_data (after potential selected_images empty init): {article_generation_data}")


        # Button to indicate data is ready and user can proceed to the next cell.
        # This button is for user guidance only.
        print("\n--- 次のステップ ---")
        print("UIで画像を生成・選択してください。選択が完了したら、次のセル（記事本文生成・投稿UI）に進んでください。")

        proceed_to_body_button_indicator = widgets.Button(description='本文生成に進む (UI操作後に次のセルを実行)', button_style='info', disabled=True) # Make disabled
        display(proceed_to_body_button_indicator)


    print("DEBUG (Image UI): Finished displaying UI.")


print("\n画像生成と画像選択UIプロセス実行終了。UIが表示されている場合は操作し、その後次のセルを実行してください。")

"""# 記事本文生成　6b45381f"""

# This cell handles generating the main article body, suggesting tags,
# displaying a final editing UI, and handling publishing to WordPress
# and updating internal records (Google Sheets).
# It relies on 'article_generation_data' being populated by a previous step (af705a0178 or 9ddb9170),
# which should contain the selected candidate details, chosen title, and selected image info.
# It also relies on helper functions defined in cell 18 for Google Sheets updates.

import ipywidgets as widgets
from IPython.display import display, clear_output, HTML # Keep HTML for displaying formatted content
import textwrap
import os
import time
from openai import OpenAI
import json
import re
import traceback
import requests # For uploading images to WordPress
import mimetypes # For determining image MIME type
import base64 # For encoding images if needed
from datetime import datetime # Import datetime class explicitly for updates
import pandas as pd # Ensure pandas is imported for df checks


# Assuming article_generation_data is populated by a previous cell (af705a0178 or 9ddb9170)
# It should contain keys like 'kadai_id', 'template_text', 'record_text', 'article_title',
# 'selected_images' (list of dicts), and 'selected_record_index'.
global article_generation_data # Declare global variable

# Assuming gc (gspread client), update_article_history, update_kiroku_article_date, post_to_x
# are available from cell 18 and authentication cell.
global gc
global update_article_history
global update_kiroku_article_date
global post_to_x

print("\n--- 記事本文生成、タグ提案、最終編集・投稿UI ---")

# Check if article_generation_data is available and has essential keys populated
required_data_keys = ['kadai_id', 'template_text', 'record_text', 'article_title', 'selected_record_index']
data_available = True
if 'article_generation_data' not in globals() or not isinstance(globals()['article_generation_data'], dict):
    print("エラー: 記事生成データ (article_generation_data) が見つかりません。")
    data_available = False
else:
    # Check for essential keys and non-None values
    for key in required_data_keys:
        if key not in article_generation_data or article_generation_data.get(key) is None:
            # Explicitly check if selected_record_index is None, which is a specific error case
            if key == 'selected_record_index' and article_generation_data.get(key) is None:
                 print(f"エラー: article_generation_data に必須キー '{key}' が見つからないか、値が None です。前のステップ (`af705a0178` または再生成されたセル) を確認してください。")
            else:
                 print(f"エラー: article_generation_data に必須キー '{key}' が見つからないか、値が None です。")
            print(f"DEBUG: article_generation_data content: {article_generation_data}")
            data_available = False
            break
    # Also check if essential text fields are empty strings after stripping
    if all(key in article_generation_data for key in ['kadai_id', 'template_text', 'record_text', 'article_title']):
         if any(str(article_generation_data.get(key, '')).strip() == '' for key in ['kadai_id', 'template_text', 'record_text', 'article_title']):
              empty_keys = [key for key in ['kadai_id', 'template_text', 'record_text', 'article_title'] if str(article_generation_data.get(key, '')).strip() == '']
              print(f"警告: article_generation_data の必須フィールド ({empty_keys}) が空です。本文生成に影響する可能性があります。")
              # Decide if this should prevent execution - for now, let's allow but warn


# Check if gspread client and helper functions are available
helper_functions_available = True
required_helpers = ['gc', 'update_article_history', 'update_kiroku_article_date', 'post_to_x']
# Check for existence in global scope and if they are callable functions (except gc)
for helper_name in required_helpers:
    if helper_name == 'gc':
        if helper_name not in globals() or globals()[helper_name] is None:
             print(f"エラー: 必要なヘルパー ({helper_name}) が利用できません。Google Sheetsへの書き込み機能は動作しません。認証セルを実行してください。")
             # Don't set helper_functions_available to False yet, only if other functions are missing
             # gc is checked separately before sheets operations
    elif helper_name not in globals() or not callable(globals()[helper_name]):
        print(f"エラー: 必要なヘルパー関数 ({helper_name}) が利用できません。投稿およびシート更新機能は動作しません。セル 18 を実行してください。")
        helper_functions_available = False


if not data_available:
    print("必要な記事生成データが不足しているため、記事本文生成・投稿プロセスをスキップします。")
    print("以下のステップを順番に実行してください:")
    print("1. セル `dbfc915c` (記事候補抽出)")
    print("2. セル `4dc514cd` (記事候補選択UI) を実行し、候補を選択してボタンをクリック")
    print("3. セル `af705a0178` または再生成されたセル (例: 9ddb9170) を実行し、データが正しく読み込まれるか確認")
    print("4. セル `3c6a0178` (タイトル選択) を実行し、タイトルを確定")
    print("5. セル `5a61dd18` (画像選択) を実行し、画像を確定")
    print("6. セル `6b45381f` (現在のセル) を実行")
    # Stop processing if data is not available
else:
    # Retrieve data from the global variable
    selected_kadai_id = article_generation_data.get('kadai_id')
    selected_template_text = article_generation_data.get('template_text')
    selected_record_text = article_generation_data.get('record_text')
    final_article_title = article_generation_data.get('article_title')
    selected_images_for_body_gen = article_generation_data.get('selected_images', []) # Get selected images list
    selected_record_index = article_generation_data.get('selected_record_index') # Get the record index


    print(f"対象課題ID: {selected_kadai_id}")
    print(f"最終的な記事タイトル: {final_article_title}")
    # Indicate which record index is being used based on loaded data
    print(f"使用する記録行のインデックス (df_kiroku): {selected_record_index}")
    print(f"DEBUG (6b45381f): Retrieved selected_images_for_body_gen from article_generation_data: {len(selected_images_for_body_gen)} images.")
    for i, img_info in enumerate(selected_images_for_body_gen):
        print(f"DEBUG (6b45381f): Retrieved Image {i+1}: URL='{img_info.get('url', 'N/A')[:50]}...', Status='{img_info.get('status', 'N/A')}'")
    print(f"DEBUG (6b45381f): Retrieved selected_record_index from article_generation_data: {selected_record_index}")


    # --- Article Body Generation ---
    openai_client = None # Initialize OpenAI client
    body_gen_error_message = None # Initialize error message variable
    generated_article_body = "" # Variable to hold the generated body text
    generated_tags = [] # Variable to hold suggested tags

    print("\n--- 記事本文、タグを自動生成中 ---")

    # Initialize OpenAI client for body generation
    try:
        api_key = os.getenv("OPENAI_API_KEY")
        if not api_key:
            print("エラー: 環境変数 'OPENAI_API_KEY' が設定されていません。記事本文・タグ生成をスキップします。")
            body_gen_error_message = "OpenAI APIキーが設定されていません。"
            # Set client to None so generation is skipped
        else:
            openai_client = OpenAI(api_key=api_key)
            # print("DEBUG: OpenAI client initialized for body generation.")
    except Exception as e:
        print(f"エラー: OpenAIクライアントの初期化に失敗しました: {e}。記事本文・タグ生成をスキップします。")
        body_gen_error_message = f"OpenAIクライアント初期化エラー: {e}"
        openai_client = None

    # Define the main generation prompt template
    # Include instructions for tags and format
    article_gen_prompt_template = textwrap.dedent("""
あなたはスポーツ指導記録を元に、読者にとって有益で魅力的なWordPressブログ記事の本文とタグを生成するAIライターです。
以下の【記事タイトル】、【記事テンプレート】、そして【指導記録】を元に、記事本文と提案タグを生成してください。

【記事タイトル】:
{article_title}

【記事テンプレート】:
{template_text}

【指導記録】:
{record_text}

【生成に関する指示】:
- テンプレートの構成案に沿って、読者が共感し、学びを得られるような記事本文を作成してください。
- 指導記録の具体的な内容を引用・解説しながら、読者に伝わるように記述してください。
- 読者タイプ（テンプレートに記載）に合わせた言葉遣いや視点を意識してください。
- 記事本文はMarkdown形式で記述し、適切な見出し（##, ###など）や箇条書き（-, *, +）、太字（**太字**）を活用してください。
- 記事本文の後に、必ずMarkdownの箇条書きで「提案タグ」を5〜10個リストアップしてください。タグは記事の内容を正確に表し、検索されやすいキーワードを選んでください。

【重要】
- 回答は、まず記事本文を記述し、その後に空行を挟んで「提案タグ」の箇条書きを続けてください。それ以外の前置きや説明は含めないでください。
- 記事本文と提案タグの間には明確な区切り（例: 空行）を入れてください。
- 生成する記事本文は、読者にとって価値のあるオリジナルのコンテンツとなるように、指導記録を単に要約するのではなく、解説や示唆を加えてください。
""").strip()


    # Function to generate article body and tags using OpenAI
    # MODIFIED: Added optional additional_instructions parameter
    def generate_article_body_and_tags(article_title, template_text, record_text, openai_client, additional_instructions=None):
        """Generates article body and tags using OpenAI based on provided data."""
        print("DEBUG: generate_article_body_and_tags called.")
        if openai_client is None:
            print("ERROR: OpenAI client not available for generation.")
            return None, None, "OpenAIクライアントが利用できません。"

        full_prompt = article_gen_prompt_template.format(
            article_title=article_title,
            template_text=template_text,
            record_text=record_text
        )

        # MODIFIED: Append additional instructions to the prompt if provided
        if additional_instructions and additional_instructions.strip():
             print(f"DEBUG: Additional instructions provided: '{additional_instructions[:100]}...'")
             full_prompt += f"\n\n【追加の生成指示】:\n{additional_instructions.strip()}"


        print("DEBUG: Sending prompt to OpenAI API...")
        try:
            completion_response = openai_client.chat.completions.create(
                model="gpt-4o-mini", # Or another suitable model
                messages=[
                    {"role": "system", "content": "あなたはスポーツ指導記録からブログ記事本文とタグを生成するAIライターです。"},
                    {"role": "user", "content": full_prompt}
                ],
                max_tokens=3000, # Adjust token limit for article body
                temperature=0.8 # Adjust creativity
            )

            if completion_response.choices and completion_response.choices[0].message and completion_response.choices[0].message.content:
                raw_output = completion_response.choices[0].message.content.strip()
                print("DEBUG: Raw generation output (first 500 chars):\n", raw_output[:500]+"...")

                # Split the output into body and tags
                # Look for a blank line or a clear separator between body and tags
                parts = raw_output.split('\n\n', 1) # Split by the first double newline

                generated_body = parts[0].strip()
                raw_tags_part = parts[1].strip() if len(parts) > 1 else ""

                # Parse the tags part (expecting Markdown list)
                generated_tags_list = [re.sub(r'^\s*[-*+]\s*', '', line).strip() for line in raw_tags_part.split('\n') if line.strip()]
                print(f"DEBUG: Parsed {len(generated_tags_list)} tags.")

                return generated_body, generated_tags_list, None # Return body, tags, and no error message

            else:
                print("警告: 本文・タグ生成APIからの応答がありませんでした。")
                return None, None, "OpenAIからの本文・タグ生成応答が空でした。"

        except Exception as api_e:
            print(f"エラー: 本文・タグ生成API呼び出し中に予期せぬエラーが発生しました: {api_e}")
            print(traceback.format_exc())
            return None, None, f"本文・タグ生成APIエラー: {api_e}"


    # --- UI for Editing and Publishing ---
    output_area_final_ui = widgets.Output() # Use a dedicated output area for the final UI
    display(output_area_final_ui)

    with output_area_final_ui:
        clear_output(wait=True)
        print("DEBUG (Final UI): Inside output_area_final_ui context.")

        print("\n--- 最終記事確認・編集・投稿 ---")

        # Display Title
        print("\n**記事タイトル:**")
        final_title_display = widgets.Textarea(
            value=final_article_title,
            layout=widgets.Layout(width='95%', height='50px'),
            disabled=True # Display only, editing is done in a separate field if needed
        )
        display(final_title_display)


        # --- Article Body Textarea (Editable) ---
        print("\n**記事本文 (編集可):**")
        # Initial generation attempt
        if openai_client:
             generated_article_body, generated_tags, body_gen_error_message = generate_article_body_and_tags(
                 final_article_title, selected_template_text, selected_record_text, openai_client
             )
             if body_gen_error_message:
                  generated_article_body = f"記事本文生成エラー: {body_gen_error_message}"
                  generated_tags = ["タグ生成エラー"]
                  print(f"警告: 記事本文生成に失敗しました: {body_gen_error_message}")
             else:
                  print("記事本文とタグ候補を生成しました。")
        else:
            generated_article_body = "OpenAIクライアントが利用できないため、記事本文は生成されませんでした。手動で入力してください。"
            generated_tags = ["OpenAI利用不可"]
            print("警告: OpenAIクライアントが利用できないため、記事本文・タグ生成はスキップされました。")


        article_body_textarea = widgets.Textarea(
            value=generated_article_body,
            layout=widgets.Layout(width='95%', height='600px'), # Make it tall for editing
            disabled=False # This is the editable field
        )
        display(article_body_textarea)

        # --- Additional Instructions and Regenerate Button ---
        # Ensure Additional Instructions Textarea and Regenerate Button are created and displayed
        print("\n**追加の生成指示 (任意):**")
        additional_instructions_textarea = widgets.Textarea(
            value='',
            placeholder='例: 「〇〇の点をさらに詳しく」「読者への問いかけを追加」「トーンをより親しみやすく」など、再生成のための指示を入力',
            layout=widgets.Layout(width='95%', height='80px')
        )
        display(additional_instructions_textarea)

        regenerate_button = widgets.Button(description='本文・タグを再生成', button_style='primary')
        display(regenerate_button)

        # --- Regenerate Button Click Handler ---
        def on_regenerate_button_clicked(b):
            print("\n--- 再生成ボタンがクリックされました ---")
            if openai_client is None:
                 print("エラー: OpenAIクライアントが利用できないため、再生成できません。APIキーを確認してください。")
                 return

            current_body_text = article_body_textarea.value # Get current text from the textarea (optional, usually regenerate from source)
            additional_instructions = additional_instructions_textarea.value # Get instructions from the additional instructions textarea

            # Clear previous generation results display
            # (This is just clearing the output in the UI area, not the textareas)
            with output_area_final_ui:
                 # clear_output(wait=True) # Don't clear everything, just update parts
                 print("\n--- 再生成中 ---")

            # Perform regeneration
            new_generated_body, new_generated_tags, regen_error_message = generate_article_body_and_tags(
                final_article_title, selected_template_text, selected_record_text, openai_client, additional_instructions
            )

            # Update the textareas and tag display with new results
            with output_area_final_ui: # Use the same output area to update UI elements
                 if regen_error_message:
                      print(f"再生成に失敗しました: {regen_error_message}")
                      # Optionally update textareas with error message
                      # article_body_textarea.value = f"再生成エラー: {regen_error_message}"
                      # tags_display.value = "タグ再生成エラー"
                 else:
                      print("再生成が完了しました。")
                      article_body_textarea.value = new_generated_body # Update body textarea
                      # Update the tags display (need to find/reference the tags display widget)
                      # Assuming tags_display widget exists and is displayed.
                      # If not, we might need to recreate/update its content.
                      # A better approach is to have a dedicated Output widget for tags display.
                      update_tags_display(new_generated_tags) # Call a helper function to update tags display

            print("DEBUG: 再生成処理完了。")

        regenerate_button.on_click(on_regenerate_button_clicked)


        # --- Tags Display (Non-editable) ---
        print("\n**提案タグ:**")
        # Initial tags display
        tags_display = widgets.Textarea(
            value=', '.join(generated_tags), # Join tags with comma for display
            layout=widgets.Layout(width='95%', height='50px'),
            disabled=True # Display only
        )
        display(tags_display)

        # Helper function to update the tags display widget
        def update_tags_display(tags_list):
             print("DEBUG: update_tags_display called.")
             # Find the tags_display widget if it exists in the displayed widgets
             # A simpler way is to make tags_display a global variable or pass it.
             # Since it's defined in the same scope, we can just reference it.
             tags_display.value = ', '.join(tags_list) # Update its value
             print("DEBUG: tags_display widget updated.")


        # --- WordPress Publish Button ---
        print("\n--- WordPress投稿 ---")
        publish_wp_button = widgets.Button(description='WordPressに下書き投稿', button_style='success')
        display(publish_wp_button)

        # --- WordPress Publish Button Click Handler ---
        def on_publish_wp_button_clicked(b):
            print("\n--- WordPress投稿ボタンがクリックされました ---")
            # MODIFIED: Initialize variables that might not be set if preceding steps/conditions fail
            selected_category_slug = '' # Initialize with an empty string
            uploaded_image_id = None
            uploaded_image_url = None
            wordpress_url = None
            wordpress_post_id = None
            wp_publish_status = "skipped" # Default status before attempt
            wp_publish_message = "投稿処理開始前スキップ"


            if not helper_functions_available:
                 print("エラー: シート更新またはX投稿のヘルパー関数が利用できません。投稿処理をスキップします。")
                 wp_publish_status = "failed" # Set status to failed if helpers are missing
                 wp_publish_message = "ヘルパー関数不足"
                 # Return early or continue with skipped status
                 # Let's continue to attempt Sheets update with failure status if gc is available
            if gc is not None:
                print("エラー: Google Sheetsクライアントが利用できません。投稿後のシート更新に失敗します。")
                # Decide if we should still attempt WP publish - let's allow it but warn
                # No change to wp_publish_status/message yet, as WP publish might still succeed


            # Gather final data from UI
            final_article_body = article_body_textarea.value
            # Get tags from the *current* value of the tags_display textarea (user might have edited it manually if not disabled)
            # Or get tags from the list variable if the textarea is disabled and the list is the source of truth.
            # Assuming the tags_display is just a display, use the generated_tags list or parse the textarea value.
            # Let's parse the current value of the tags_display textarea as the final tags list.
            final_tags_str = tags_display.value
            final_tags_list = [tag.strip() for tag in final_tags_str.split(',') if tag.strip()]
            print(f"DEBUG: Final tags list parsed from display: {final_tags_list}")

            # Get selected image URL and ID from article_generation_data (populated by 5a61dd18 or earlier)
            # Safely access the first element of the list
            # MODIFIED: More robust way to get the first element or None
            final_selected_image_info = None
            if selected_images_for_body_gen: # Check if list is not empty
                final_selected_image_info = selected_images_for_body_gen[0]

            final_featured_image_url = final_selected_image_info.get('url') if final_selected_image_info else None
            final_featured_image_id = final_selected_image_info.get('id') if final_selected_image_info else None # Assuming image ID is stored


            # --- WordPress Publishing Logic ---
            # Only attempt WP publish if helper functions are available (as it implies other setup might be done)
            # and if WP creds are available.
            wp_url = os.getenv("WORDPRESS_URL")
            wp_user = os.getenv("WORDPRESS_USER")
            wp_password = os.getenv("WORDPRESS_PASSWORD") # Application password recommended

            if helper_functions_available and all([wp_url, wp_user, wp_password]):
                 print("WordPress REST APIを使用して投稿を試みます...")
                 # Basic Authentication (less secure, use Application Passwords)
                 # For Application Passwords, the password is the generated application password.
                 # The username is the WordPress username.
                 auth_string = f"{wp_user}:{wp_password}"
                 # Encode in Base64
                 auth_header = base64.b64encode(auth_string.encode('utf-8')).decode('utf-8')

                 headers = {
                     'Authorization': f'Basic {auth_header}',
                     'Content-Type': 'application/json' # For creating/updating posts
                 }

                 # --- Upload Featured Image if selected and not already uploaded ---
                 # Re-initialize image variables for this attempt
                 uploaded_image_id = None
                 uploaded_image_url = None

                 if final_featured_image_url:
                     print(f"DEBUG: Attempting to upload featured image from URL: {final_featured_image_url[:50]}...")
                     # Need a function to download the image and upload it to WP media library
                     # This is a complex step and needs error handling.

                     # Check if image ID is already available (means it was uploaded in a previous run or step)
                     if final_featured_image_id:
                         print(f"DEBUG: Featured image ID {final_featured_image_id} already available. Assuming already uploaded.")
                         uploaded_image_id = final_featured_image_id
                         uploaded_image_url = final_featured_image_url # Use the original URL if ID is known
                     else:
                         # Image needs to be downloaded and uploaded
                         # This requires a separate function or inline logic
                         try:
                             # Download the image content
                             img_response = requests.get(final_featured_image_url, stream=True)
                             img_response.raise_for_status() # Raise an exception for bad status codes

                             # Determine file name and MIME type
                             content_type = img_response.headers.get('content-type')
                             if not content_type or not content_type.startswith('image/'):
                                  print(f"警告: ダウンロードしたURLのContent-Type '{content_type}' が画像ではありません。画像アップロードをスキップします。")
                                  wp_publish_message = "画像URLが無効または画像ではない" # Update message if image upload fails
                             else:
                                  mime_type = content_type
                                  # Try to guess extension from MIME type, or use a default
                                  extension = mimetypes.guess_extension(mime_type) or '.jpg' # Default to .jpg
                                  # Create a simple filename (can improve this)
                                  filename = f"featured_image_{int(time.time())}{extension}"

                                  # Prepare headers for media upload
                                  media_headers = {
                                       'Authorization': f'Basic {auth_header}',
                                       'Content-Type': mime_type,
                                       'Content-Disposition': f'attachment; filename="{filename}"'
                                  }

                                  # Upload the image file content
                                  media_endpoint = f"{wp_url}/wp-json/wp/v2/media"
                                  print(f"DEBUG: Uploading image to WP media library: {media_endpoint}")
                                  upload_response = requests.post(media_endpoint, headers=media_headers, data=img_response.content)
                                  upload_response.raise_for_status() # Raise for errors

                                  media_data = upload_response.json()
                                  uploaded_image_id = media_data.get('id')
                                  uploaded_image_url = media_data.get('source_url') # The URL WP assigned
                                  print(f"DEBUG: Image uploaded successfully. Media ID: {uploaded_image_id}, URL: {uploaded_image_url}")

                         except requests.exceptions.RequestException as req_e:
                             print(f"エラー: 画像のダウンロードまたはアップロード中にHTTPエラーが発生しました: {req_e}")
                             print(traceback.format_exc())
                             wp_publish_message = f"画像アップロードHTTPエラー: {req_e}" # Update message if image upload fails
                         except Exception as e:
                             print(f"エラー: 画像アップロード中に予期せぬエラーが発生しました: {e}")
                             print(traceback.format_exc())
                             wp_publish_message = f"画像アップロード予期せぬエラー: {e}" # Update message if image upload fails


                 # --- Prepare Post Data ---
                 post_data = {
                     'title': final_article_title,
                     'content': final_article_body,
                     'status': 'draft',  # Publish as draft first
                     'categories': [],   # Categories will be added based on mapping
                     'tags': final_tags_list # Use the parsed tags list
                 }

                 # Add featured image ID if upload was successful
                 if uploaded_image_id:
                     post_data['featured_media'] = uploaded_image_id
                     print(f"DEBUG: Featured media ID {uploaded_image_id} added to post data.")

                 # --- Add Category (based on template/record, mapped to slug) ---
                 # This requires the category slug mapping to be available globally.
                 # Assuming 'category_slug_mapping' is loaded in cell 246c7b8c
                 # Assuming category_slug_mapping is {Template Name: {'id': ..., 'slug': ...}}
                 if 'category_slug_mapping' in globals() and isinstance(globals()['category_slug_mapping'], dict):
                     # Need to determine the category slug from the selected candidate data or template
                     # Assuming the template_text contains a "カテゴリ（主）" field
                     category_match = re.search(r"カテゴリ（主）:\s*(.+)", selected_template_text)
                     if category_match:
                         template_category_name = category_match.group(1).strip()
                         # Find the category info in the mapping
                         category_info = globals()['category_slug_mapping'].get(template_category_name)
                         if category_info and isinstance(category_info, dict):
                              category_id = category_info.get('id')
                              # selected_category_slug is already initialized to '' at the start
                              selected_category_slug = category_info.get('slug', '') # Get the slug here, default to empty string
                              if category_id is not None:
                                   post_data['categories'].append(category_id)
                                   print(f"DEBUG: Added category ID {category_id} ('{template_category_name}') to post data.")
                              else:
                                  print(f"警告: マッピングにテンプレートカテゴリ名 '{template_category_name}' はありますが、有効なカテゴリーIDがありません。カテゴリーは設定されません。")
                         else:
                            print(f"警告: テンプレートカテゴリ名 '{template_category_name}' に対応するマッピング情報が見つかりませんでした。カテゴリーは設定されません。")
                     else:
                         print("警告: テンプレートに 'カテゴリ（主）' が見つかりませんでした。カテゴリーは設定されません。")
                 else:
                    print("警告: カテゴリースラッグマッピング (category_slug_mapping) が利用できません。カテゴリーは設定されません。セル 246c7b8c を実行してください。")


                 # --- Send Post Request ---
                 posts_endpoint = f"{wp_url}/wp-json/wp/v2/posts"
                 print(f"DEBUG: Sending post request to {posts_endpoint}")

                 try:
                     # Use json=post_data to automatically set Content-Type to application/json
                     publish_response = requests.post(posts_endpoint, headers=headers, json=post_data)
                     publish_response.raise_for_status() # Raise an exception for bad status codes (4xx or 5xx)

                     publish_result = publish_response.json()

                     wp_publish_status = "success"
                     wp_publish_message = "投稿成功"
                     wordpress_url = publish_result.get('link') # Get the published URL
                     wordpress_post_id = publish_result.get('id') # Get the post ID
                     print(f"WordPressへの投稿が完了しました (ステータス: {publish_result.get('status')})。")
                     print(f"投稿URL: {wordpress_url}")
                     print(f"投稿ID: {wordpress_post_id}")

                 except requests.exceptions.RequestException as req_e:
                     print(f"エラー: WordPressへの投稿中にHTTPエラーが発生しました: {req_e}")
                     print(traceback.format_exc())
                     wp_publish_status = "failed"
                     wp_publish_message = f"WordPress投稿HTTPエラー: {req_e}"
                     wordpress_url = None
                     wordpress_post_id = None
                 except Exception as e:
                     print(f"エラー: WordPressへの投稿中に予期せぬエラーが発生しました: {e}")
                     print(traceback.format_exc())
                     wp_publish_status = "failed"
                     wp_publish_message = f"WordPress投稿予期せぬエラー: {e}"
                     wordpress_url = None
                     wordpress_post_id = None
            else:
                # WP credentials or helper functions not available
                print("警告: WordPress認証情報が不足しているか、ヘルパー関数が利用できないため、WordPressへの投稿はスキップされました。")
                wp_publish_status = "skipped" # Explicitly set skipped status if not attempted
                wp_publish_message = "WordPress投稿スキップ (認証情報/ヘルパー不足)"


            # --- Update Google Sheets (記事履歴DB and 記録シート) ---
            # This happens regardless of WP publish success/failure, but data written depends on status
            # Only attempt sheets update if gc client and necessary helper functions are available
            if gc is not None and helper_functions_available:
                print("\n--- Google Sheetsの更新を開始します ---")
                try:
                    # Prepare data for article history update
                    # Simplify the result data to match the structure expected by update_article_history
                    # Use the local selected_category_slug variable which is now initialized
                    simplified_publishing_results_for_append = [{
                        'kadai_id': selected_kadai_id,
                        'article_title': final_article_title,
                        'wordpress_url': wordpress_url,
                        'wordpress_post_id': wordpress_post_id,
                        'wp_status': wp_publish_status, # Pass the final status
                        'selected_record_index': selected_record_index, # Pass the record index
                        'tags': final_tags_list, # Pass the final tags list
                        'featured_image_url': uploaded_image_url if uploaded_image_id else final_featured_image_url, # Use uploaded URL if available, otherwise original
                        'featured_image_id': uploaded_image_id, # Pass the uploaded image ID
                        # Use the local selected_category_slug variable
                        'selected_category_slug': selected_category_slug
                    }]

                    # Update Article History DB sheet (df_kiji)
                    # Assuming df_kiji is available globally from a previous loading cell
                    if 'df_kiji' in globals() and isinstance(globals()['df_kiji'], pd.DataFrame):
                        print("DEBUG: df_kiji available for update.")
                        # Pass the global df_kiji to the function, it will return the updated one
                        df_kiji = update_article_history(simplified_publishing_results_for_append, globals()['df_kiji'])
                        # Update the global df_kiji variable with the returned DataFrame
                        globals()['df_kiji'] = df_kiji
                    else:
                        print("エラー: df_kiji が利用できません。記事履歴DBシートの更新をスキップします。")

                    # Update 記録シート ('記事作成日')
                    # This update only happens if WP publish was successful
                    if wp_publish_status == "success":
                         # Use the publish date string from update_article_history or get it here
                         # Let's get the current time here for consistency with the logic in update_kiroku_article_date
                         # Use datetime.now() assuming from datetime import datetime
                         publish_date_for_record_sheet = datetime.now().strftime('%Y/%m/%d') # Format for the record sheet date column (assuming YYYY/MM/DD)

                         # Assuming df_kiroku is available globally from a previous loading cell
                         if 'df_kiroku' in globals() and isinstance(globals()['df_kiroku'], pd.DataFrame):
                             print("DEBUG: df_kiroku available for update.")
                             # Pass the global df_kiroku to the function, it will return the updated one
                             df_kiroku = update_kiroku_article_date(selected_record_index, publish_date_for_record_sheet, globals()['df_kiroku'])
                             # Update the global df_kiroku variable with the returned DataFrame
                             globals()['df_kiroku'] = df_kiroku
                         else:
                             print("エラー: df_kiroku が利用できません。記録シート ('記事作成日') の更新をスキップします。")
                    else:
                         print("警告: WordPress投稿が成功しなかったため、記録シート ('記事作成日') の更新はスキップされました。")


                except Exception as e:
                    print(f"エラー: Google Sheets更新処理中に予期せぬエラーが発生しました: {e}")
                    print(traceback.format_exc())
            else:
                 print("警告: Google Sheetsクライアントまたはヘルパー関数が利用できないため、Google Sheetsの更新はスキップされました。")


            # --- Post to X (formerly Twitter) ---
            # This happens only if WP publish was successful and X posting is enabled/configured
            # Check if post_to_x helper is available
            if wp_publish_status == "success" and wordpress_url and 'post_to_x' in globals() and callable(globals()['post_to_x']):
                print("\n--- X (旧Twitter) への投稿を開始します ---")
                try:
                    # Call the post_to_x function defined in cell 18
                    x_post_result = post_to_x(final_article_title, wordpress_url)
                    if x_post_result.get('status') == 'success':
                        print("Xへの投稿が完了しました。")
                    else:
                        print(f"警告: Xへの投稿に失敗またはスキップされました: {x_post_result.get('message', '詳細不明')}")
                except Exception as e:
                    print(f"エラー: X投稿処理中に予期せぬエラーが発生しました: {e}")
                    print(traceback.format_exc())
            elif wp_publish_status != "success":
                 print("警告: WordPress投稿が成功しなかったため、Xへの投稿はスキップされました。")
            elif not wordpress_url:
                 print("警告: WordPress URLが取得できなかったため、Xへの投稿はスキップされました。")
            else:
                 print("DEBUG: X post skipped (conditions not met or helper not available).")


            print("\n--- 投稿および更新プロセス完了 ---")
            if wp_publish_status == "success":
                 print(f"記事はWordPressに下書き投稿されました。URL: {wordpress_url}")
                 print("記事履歴DBシートと記録シートの更新を試みました。")
                 if gc is None or not helper_functions_available:
                      print("警告: シート更新はスキップされているか、エラーが発生した可能性があります。")
            else:
                 print(f"WordPressへの投稿に失敗しました。ステータス: {wp_publish_status}, メッセージ: {wp_publish_message}")
                 if gc is None or not helper_functions_available:
                      print("警告: シート更新はスキップされているか、エラーが発生した可能性があります。")


        # Link the button click to the handler function
        publish_wp_button.on_click(on_publish_wp_button_clicked)

        print("DEBUG: WordPress publish button event handler assigned.")


    except NameError as ne:
        print(f"エラー: 必要な関数やクラスが見つかりません: {ne}. 適切なセルを実行してください。")
        print(traceback.format_exc())
    except Exception as e:
        print(f"記事本文生成、編集UI表示、または投稿準備中に予期せぬエラーが発生しました: {e}")
        print(traceback.format_exc()) # Use traceback.format_exc() for standard format


print("\n記事本文生成、タグ提案、最終編集・投稿UIプロセス実行終了。UIが表示されている場合は操作してください。")

"""# NOTEセクション　409411f5"""

# Note投稿用（ナラティブスタイル）記事本文生成UI

import ipywidgets as widgets
from IPython.display import display, clear_output
import textwrap
import os
import time
from openai import OpenAI
import json
import re
import traceback
import pandas as pd # Import pandas to potentially access df_kiji for the URL

print("\n--- Note投稿用（ナラティブスタイル）記事本文生成UI ---")

# Check if required data is available from previous steps
if 'article_generation_data' not in globals():
    print("エラー: 'article_generation_data' が見つかりません。前のステップ（タイトル選択）を実行してください。")
else:
    # Retrieve the data needed for article generation
    selected_kadai_id = article_generation_data.get('kadai_id')
    selected_template_text = article_generation_data.get('template_text')
    selected_record_text = article_generation_data.get('record_text')
    final_article_title = article_generation_data.get('article_title')

    if not all([selected_kadai_id, selected_template_text, selected_record_text, final_article_title]):
         print("エラー: 'article_generation_data' に必要な情報が不足しています。前のステップを確認してください。")
    else:
        print(f"対象課題ID: {selected_kadai_id}")
        print(f"使用する記事タイトル: {final_article_title}")

        # Display the selected template and record data again for context
        print(f"\n---- 使用するテンプレート (課題ID: {selected_kadai_id}) ----\n")
        display(widgets.Textarea(value=selected_template_text, layout=widgets.Layout(width='95%', height='200px'), disabled=True))
        print(f"\n---- 元の記録データ全文 (課題ID: {selected_kadai_id}) ----\n")
        display(widgets.Textarea(value=selected_record_text, layout=widgets.Layout(width='95%', height='200px'), disabled=True))
        print("---------------------------------------------\n")

        # Optional: Add a text area for further instructions, similar to the previous UI
        # This textarea's value is NOT currently used in the article_writer prompt structure
        # as the style='narrative' controls the prompt. It's kept here in case the user
        # wishes to add this functionality later.
        further_instructions_input = widgets.Textarea(
            value='',
            placeholder='Note投稿用本文生成のための追加の詳細指示を入力してください（例: 特定の点をより共感的に記述する、表現を柔らかくするなど）',
            description='追加指示:',
            disabled=False,
            layout=widgets.Layout(width='80%', height='100px')
        )

        generate_note_body_button = widgets.Button(description='Note本文（ナラティブ）を生成', button_style='info')
        output_area_note_body = widgets.Output()

        # Extract reader type from template text for article_writer
        reader_type_match = re.search(r"【読者タイプ】:\s*(.+?)向け", selected_template_text)
        extracted_reader_type = reader_type_match.group(1).strip() if reader_type_match else "不明"
        print(f"抽出された読者タイプ: {extracted_reader_type}")


        def on_generate_note_body_clicked(b):
            with output_area_note_body:
                clear_output(wait=True)
                print("\nNote本文（ナラティブスタイル）を生成中です...")

                # Ensure article_writer function is defined and accessible
                if 'article_writer' not in globals() or not callable(article_writer):
                    print("エラー: 'article_writer' 関数が定義されていません。前のステップを確認してください。")
                    return

                # Call the article_writer function with the narrative style
                generated_article_body_note = article_writer(
                    template_text=selected_template_text,
                    record_text=selected_record_text,
                    kadai_id=selected_kadai_id,
                    article_title=final_article_title, # Pass the final selected/input title
                    article_style='narrative', # Explicitly request narrative style
                    reader_type=extracted_reader_type # Pass the extracted reader type
                )

                if not generated_article_body_note:
                    print("\n警告: Note本文（ナラティブスタイル）が生成されませんでした。Assistantからの応答を確認してください。")
                    return # Stop if body generation failed

                print("\nNote本文（ナラティブスタイル）の生成が完了しました。")

                # --- Call Assistant for Tag Suggestions (specifically for Note/Narrative) ---
                print("\n--- タグ自動提案 (Note/ナラティブ用) ---")
                print("指導記録全文を元に、Note記事にふさわしいタグを提案します。")

                suggested_tags = []
                # Using the prompt provided by the user in cell PB3mmTlSGOZg - adjust rules for Note if needed
                # For simplicity, we'll reuse the same tag prompt but frame it for Note context.
                tag_prompt = textwrap.dedent(f"""
あなたは、スポーツ指導記録をもとに Note 記事を投稿するサポート AI です。
以下の【指導記録】をもとに、記事にふさわしいタグを 5〜7 個、ハッシュタグ形式（#〜）で提案してください。

【タグ出力ルール】
- 技術領域に関するタグ（例：#サーブ #ストローク #ボレー）
- 指導テーマに関するタグ（例：#フォーム改善 #体感指導 #継続支援）
- 対象読者に関するタグ（例：#指導者向け #保護者向け #選手向け）
- 成長段階や競技レベル（例：#初心者 #大会出場レベル #中高生対象）
- その他、本文のキーワードから重要そうなもの（例：#トロフィーポーズ #取り組み継続）
- **Noteの読者が興味を持ちそうな、共感や学びにつながるようなタグを優先してください。**

【出力形式】
- タグのみ出力、説明不要
- 1 行でカンマ区切り（例：#サーブ, #体感指導, #保護者向け, #初心者, #トロフィーポーズ）

## 【指導記録】

{selected_record_text}

* * *

タグをお願いします。
""").strip()

                try:
                    client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
                    # Reusing the TEMPLATE_ASSISTANT_ID for tag generation
                    tag_assistant_id = os.getenv("TEMPLATE_ASSISTANT_ID")

                    if not tag_assistant_id:
                         print("エラー: 環境変数 'TEMPLATE_ASSISTANT_ID' が設定されていません。タグ生成AssistantのIDが必要です。")
                    else:
                        thread = client.beta.threads.create()
                        client.beta.threads.messages.create(thread_id=thread.id, role="user", content=tag_prompt)
                        run = client.beta.threads.runs.create(thread_id=thread.id, assistant_id=tag_assistant_id)

                        print("タグ候補を生成中です...")
                        status = None # Initialize status before loop
                        while True:
                            status = client.beta.threads.runs.retrieve(thread_id=thread.id, run_id=run.id)
                            if status.status in ["completed", "failed", "cancelled", "expired"]:
                                break
                            if status.status == "requires_action":
                                 print("Function calling is required, but not implemented in this flow.")
                                 status.status = "failed"
                                 break
                            time.sleep(2)

                        tag_reply_text = ""
                        if status and status.status == "completed":
                            messages = client.beta.threads.messages.list(thread_id=thread.id)
                            if messages.data:
                                 assistant_messages = [msg for msg in messages.data if msg.role == 'assistant']
                                 if assistant_messages:
                                      if assistant_messages[0].content:
                                          for content_block in assistant_messages[0].content:
                                              if content_block.type == 'text':
                                                   tag_reply_text += content_block.text.value + "\n"
                                      tag_reply_text = tag_reply_text.strip()

                                      if tag_reply_text:
                                           suggested_tags = [tag.strip() for tag in tag_reply_text.split(',') if tag.strip()]
                                           print(f"DEBUG: Successfully parsed {len(suggested_tags)} suggested tags for Note.")
                                      else:
                                           print("警告: タグ生成Assistantからの応答が空でした。")
                                 else:
                                         print("警告: タグ生成Assistantからの応答にAssistantのメッセージが見つかりませんでした。")
                            else:
                                 print("警告: タグ生成Assistantからの応答がありませんでした、またはテキストコンテンツがありませんでした。")

                        elif status:
                             print(f"警告: タグ生成Assistantの実行が完了しませんでした。最終ステータス: {status.status}")
                             if status.last_error:
                                 print(f"エラー詳細: {status.last_error}")
                        else:
                             print("警告: タグ生成Assistant実行ステータスが取得できませんでした。")


                except Exception as e:
                    print(f"タグ自動提案処理中に予期せぬエラーが発生しました: {e}")
                    print(traceback.format_exc())


                # --- Note Formatting Step (using the generated body and suggested tags) ---
                print("\n--- Note投稿用フォーマット ---")
                print("生成された本文とタグ、関連リンクをNote投稿用に整形します。")

                # Get WordPress URL from environment variables if available
                wordpress_base_url = os.getenv("WORDPRESS_URL")
                if not wordpress_base_url:
                     print("警告: 環境変数 'WORDPRESS_URL' が設定されていません。関連リンクは追加されません。")


                # Ensure df_kiji is available globally for the link
                if 'df_kiji' not in globals():
                    print("警告: 'df_kiji' DataFrame がグローバルスコープで見つかりません。関連リンクの検索ができません。")
                    df_kiji_for_note_link = None
                else:
                     df_kiji_for_note_link = df_kiji


                # Ensure format_for_note function is defined and accessible
                if 'format_for_note' not in globals() or not callable(format_for_note):
                     print("エラー: 'format_for_note' 関数が定義されていません。前のステップを確認してください。Noteフォーマットをスキップします。")
                     # Display only the generated body if formatting function is missing
                     # Add a fallback display here if formatting fails
                     print("\n--- 生成されたNote本文（ナラティブ）---")
                     display(widgets.Textarea(value=generated_article_body_note, layout=widgets.Layout(width='95%', height='300px'), disabled=True))
                     return


                # Call the formatting function with the generated Note body and available tags
                note_formatted_content = format_for_note(
                    article_body=generated_article_body_note, # Use the newly generated Note body (narrative style)
                    tags=suggested_tags, # Use the suggested tags
                    wordpress_url=wordpress_base_url, # Pass the WP URL for link
                    kadai_id=selected_kadai_id, # Pass the Kadai ID for link
                    df_kiji=df_kiji_for_note_link # Pass the df_kiji DataFrame for link
                )

                # Display the formatted content in a Textarea for easy copying
                print("\n--- Note投稿用コンテンツ (以下をコピーしてください) ---")
                note_output_textarea = widgets.Textarea(
                    value=note_formatted_content,
                    description='Noteコンテンツ:',
                    disabled=False,
                    layout=widgets.Layout(width='95%', height='400px')
                )
                display(note_output_textarea)

                print("\nNote投稿用のコンテンツが生成されました。上記のテキストエリアからコピーしてNoteに貼り付けてください。")


        generate_note_body_button.on_click(on_generate_note_body_clicked)

        # Display the UI elements
        # Group widgets in a VBox for better display
        note_body_ui = widgets.VBox([further_instructions_input, generate_note_body_button, output_area_note_body])
        display(note_body_ui)

print("\nNote投稿用（ナラティブスタイル）の記事本文生成UIセルを修正しました。")
print("このセルを実行し、「Note本文（ナラティブ）を生成」ボタンをクリックしてください。")
print("本文生成後、タグの提案と関連リンクを含むNote投稿用の最終フォーマットが表示されます。")

"""# 最後"""